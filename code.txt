`code.txt`

```

```

`o.txt`

```
Chatbot-gemini
├── client
│   ├── .env
│   ├── .git
│   │   ├── branches
│   │   ├── COMMIT_EDITMSG
│   │   ├── config
│   │   ├── description
│   │   ├── HEAD
│   │   ├── hooks
│   │   │   ├── applypatch-msg.sample
│   │   │   ├── commit-msg.sample
│   │   │   ├── fsmonitor-watchman.sample
│   │   │   ├── post-update.sample
│   │   │   ├── pre-applypatch.sample
│   │   │   ├── pre-commit.sample
│   │   │   ├── pre-merge-commit.sample
│   │   │   ├── prepare-commit-msg.sample
│   │   │   ├── pre-push.sample
│   │   │   ├── pre-rebase.sample
│   │   │   ├── pre-receive.sample
│   │   │   ├── push-to-checkout.sample
│   │   │   └── update.sample
│   │   ├── index
│   │   ├── info
│   │   │   └── exclude
│   │   ├── logs
│   │   │   ├── HEAD
│   │   │   └── refs
│   │   │       └── heads
│   │   │           └── master
│   │   ├── objects
│   │   │   ├── 08
│   │   │   │   └── 0d6c77ac21bb2ef88a6992b2b73ad93daaca92
│   │   │   ├── 1f
│   │   │   │   └── 03afeece5ac28064fa3c73a29215037465f789
│   │   │   ├── 37
│   │   │   │   └── 845757234ccb68531c10cf7a2ffc589c47e342
│   │   │   ├── 4d
│   │   │   │   └── 29575de80483b005c29bfcac5061cd2f45313e
│   │   │   ├── 52
│   │   │   │   └── 53d3ad9e6be6690549cb255f5952337b02401d
│   │   │   ├── 58
│   │   │   │   └── beeaccd87e230076cab531b8f418f40b6d1aeb
│   │   │   ├── 74
│   │   │   │   └── b5e053450a48a6bdb4d71aad648e7af821975c
│   │   │   ├── 7b
│   │   │   │   └── 1e172334cdc980bee9ad6a8a87cf21e0ed18d8
│   │   │   ├── 8e
│   │   │   │   └── 29b36dea7f04ae8729d8b33ecc05c3c9b0fe46
│   │   │   ├── 8f
│   │   │   │   └── 2609b7b3e0e3897ab3bcaad13caf6876e48699
│   │   │   ├── 9d
│   │   │   │   └── fc1c058cebbef8b891c5062be6f31033d7d186
│   │   │   ├── a1
│   │   │   │   └── 1777cc471a4344702741ab1c8a588998b1311a
│   │   │   ├── a4
│   │   │   │   └── e47a6545bc15971f8f63fba70e4013df88a664
│   │   │   ├── aa
│   │   │   │   └── 069f27cbd9d53394428171c3989fd03db73c76
│   │   │   ├── b7
│   │   │   │   └── 74f9efba05bc34f4b71bfca23dc005a0ef83be
│   │   │   ├── d5
│   │   │   │   └── 63c0fb10ba0e42724b21286eb546ee4e5734fc
│   │   │   ├── e4
│   │   │   │   └── c9945924667b6e4938995771ab8d913a1b318f
│   │   │   ├── e9
│   │   │   │   └── e57dc4d41b9b46e05112e9f45b7ea6ac0ba15e
│   │   │   ├── ec
│   │   │   │   └── 2585e8c0bb8188184ed1e0703c4c8f2a8419b0
│   │   │   ├── f4
│   │   │   │   └── c86f0c4dcad7f2a34102df07e3996d912fb812
│   │   │   ├── f9
│   │   │   │   └── 91a039dd5e0917bce7c861fc59bc569efc4197
│   │   │   ├── fc
│   │   │   │   └── 44b0a3796c0e0a64c3d858ca038bd4570465d9
│   │   │   ├── info
│   │   │   └── pack
│   │   └── refs
│   │       ├── heads
│   │       │   └── master
│   │       └── tags
│   ├── .gitignore
│   ├── install.sh
│   ├── package.json
│   ├── package-lock.json
│   ├── public
│   │   ├── favicon.ico
│   │   ├── index.html
│   │   ├── logo192.png
│   │   ├── logo512.png
│   │   ├── manifest.json
│   │   └── robots.txt
│   ├── README.md
│   ├── src
│   │   ├── App.css
│   │   ├── App.js
│   │   ├── App.test.js
│   │   ├── components
│   │   │   ├── AuthPage.js
│   │   │   ├── ChatPage.css
│   │   │   ├── ChatPage.js
│   │   │   ├── FileManagerWidget.js
│   │   │   ├── FileUploadWidget.js
│   │   │   ├── HistoryModal.js
│   │   │   └── SystemPromptWidget.js
│   │   ├── index.css
│   │   ├── index.js
│   │   ├── logo.svg
│   │   ├── reportWebVitals.js
│   │   ├── services
│   │   │   └── api.js
│   │   └── setupTests.js
│   └── webpack.config.js
├── docker-compose.yml
├── o.txt
├── README.md
├── server
│   ├── assets
│   │   ├── data
│   │   │   ├── code
│   │   │   ├── docs
│   │   │   ├── images
│   │   │   └── others
│   │   ├── docs
│   │   │   ├── code
│   │   │   ├── docs
│   │   │   ├── images
│   │   │   └── others
│   │   ├── images
│   │   │   ├── code
│   │   │   ├── docs
│   │   │   ├── images
│   │   │   └── others
│   │   ├── others
│   │   │   ├── code
│   │   │   ├── docs
│   │   │   ├── images
│   │   │   └── others
│   │   └── s
│   │       ├── code
│   │       ├── docs
│   │       ├── images
│   │       └── others
│   ├── backup_assets
│   │   ├── data
│   │   │   ├── backup_2025-04-01T11-06-27-547Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-50-58-722Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-51-31-076Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-55-23-558Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-59-43-725Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T12-04-23-129Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T12-08-33-186Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   └── backup_2025-04-01T12-42-58-984Z
│   │   │       ├── code
│   │   │       ├── docs
│   │   │       ├── images
│   │   │       └── others
│   │   ├── docs
│   │   │   ├── backup_2025-04-01T11-06-27-547Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-50-58-722Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-51-31-076Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-55-23-558Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-59-43-725Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T12-04-23-129Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T12-08-33-186Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   └── backup_2025-04-01T12-42-58-984Z
│   │   │       ├── code
│   │   │       ├── docs
│   │   │       ├── images
│   │   │       └── others
│   │   ├── images
│   │   │   ├── backup_2025-04-01T11-06-27-547Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-50-58-722Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-51-31-076Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-55-23-558Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-59-43-725Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T12-04-23-129Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T12-08-33-186Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   └── backup_2025-04-01T12-42-58-984Z
│   │   │       ├── code
│   │   │       ├── docs
│   │   │       ├── images
│   │   │       └── others
│   │   ├── others
│   │   │   ├── backup_2025-04-01T11-06-27-547Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-50-58-722Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-51-31-076Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-55-23-558Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T11-59-43-725Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T12-04-23-129Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   ├── backup_2025-04-01T12-08-33-186Z
│   │   │   │   ├── code
│   │   │   │   ├── docs
│   │   │   │   ├── images
│   │   │   │   └── others
│   │   │   └── backup_2025-04-01T12-42-58-984Z
│   │   │       ├── code
│   │   │       ├── docs
│   │   │       ├── images
│   │   │       └── others
│   │   └── s
│   │       ├── backup_2025-04-01T10-30-28-805Z
│   │       │   ├── code
│   │       │   ├── docs
│   │       │   ├── images
│   │       │   └── others
│   │       ├── backup_2025-04-01T11-06-22-854Z
│   │       │   ├── code
│   │       │   ├── docs
│   │       │   ├── images
│   │       │   └── others
│   │       ├── backup_2025-04-01T11-06-27-547Z
│   │       │   ├── code
│   │       │   ├── docs
│   │       │   ├── images
│   │       │   └── others
│   │       ├── backup_2025-04-01T11-50-58-722Z
│   │       │   ├── code
│   │       │   ├── docs
│   │       │   │   └── 1743505616707-CS_229.pdf
│   │       │   ├── images
│   │       │   └── others
│   │       ├── backup_2025-04-01T11-51-31-076Z
│   │       │   ├── code
│   │       │   ├── docs
│   │       │   ├── images
│   │       │   └── others
│   │       ├── backup_2025-04-01T11-55-23-558Z
│   │       │   ├── code
│   │       │   ├── docs
│   │       │   ├── images
│   │       │   └── others
│   │       ├── backup_2025-04-01T11-59-43-725Z
│   │       │   ├── code
│   │       │   ├── docs
│   │       │   ├── images
│   │       │   └── others
│   │       ├── backup_2025-04-01T12-04-23-129Z
│   │       │   ├── code
│   │       │   ├── docs
│   │       │   ├── images
│   │       │   └── others
│   │       ├── backup_2025-04-01T12-08-33-186Z
│   │       │   ├── code
│   │       │   ├── docs
│   │       │   ├── images
│   │       │   └── others
│   │       └── backup_2025-04-01T12-42-58-984Z
│   │           ├── code
│   │           ├── docs
│   │           ├── images
│   │           └── others
│   ├── config
│   │   ├── cors.js
│   │   └── db.js
│   ├── default_assets
│   │   └── engineering
│   │       ├── [10]part-2-deep-network-modern-practices.pdf
│   │       ├── [11]part-2-chapter-6.pdf
│   │       ├── [12]part-2-chapter-7.pdf
│   │       ├── [13]part-2-chapter-8.pdf
│   │       ├── [14]part-2-chapter-9.pdf
│   │       ├── [15]part-2-chapter-10.pdf
│   │       ├── [16]part-2-chapter-11.pdf
│   │       ├── [17]part-2-chapter-12.pdf
│   │       ├── [18]part-3-deep-learning-research.pdf
│   │       ├── [19]part-3-chapter-13.pdf
│   │       ├── [1]table-of-contents.pdf
│   │       ├── [20]part-3-chapter-14.pdf
│   │       ├── [21]part-3-chapter-15.pdf
│   │       ├── [22]part-3-chapter-16.pdf
│   │       ├── [2]acknowledgements.pdf
│   │       ├── [3]notation.pdf
│   │       ├── [4]chapter-1-introduction.pdf
│   │       ├── [5]part-1-basics.pdf
│   │       ├── [6]part-1-chapter-2.pdf
│   │       ├── [7]part-1-chapter-3.pdf
│   │       ├── [8]part-1-chapter-4.pdf
│   │       └── [9]part-1-chapter-5.pdf
│   ├── .env
│   ├── faiss_indices
│   │   ├── user_67ea3ddef04106c67984077c
│   │   │   ├── index.faiss
│   │   │   └── index.pkl
│   │   └── user___DEFAULT__
│   │       ├── index.faiss
│   │       └── index.pkl
│   ├── install.sh
│   ├── middleware
│   │   └── authMiddleware.js
│   ├── models
│   │   ├── ChatHistory.js
│   │   └── User.js
│   ├── package.json
│   ├── package-lock.json
│   ├── rag_service
│   │   ├── app.py
│   │   ├── config.py
│   │   ├── default.py
│   │   ├── .env
│   │   ├── faiss_handler.py
│   │   ├── file_parser.py
│   │   ├── indexes
│   │   │   ├── default.faiss
│   │   │   └── default_metadata.json
│   │   ├── initialize_default_index.py
│   │   ├── __pycache__
│   │   │   ├── config.cpython-311.pyc
│   │   │   ├── config.cpython-312.pyc
│   │   │   ├── faiss_handler.cpython-311.pyc
│   │   │   ├── faiss_handler.cpython-312.pyc
│   │   │   ├── file_parser.cpython-311.pyc
│   │   │   └── file_parser.cpython-312.pyc
│   │   ├── rag_server.py
│   │   └── requirements.txt
│   ├── routes
│   │   ├── auth.js
│   │   ├── chat.js
│   │   ├── files.js
│   │   ├── network.js
│   │   └── upload.js
│   ├── server.js
│   ├── services
│   │   └── geminiService.js
│   └── utils
│       ├── assetCleanup.js
│       └── networkUtils.js
├── server New.js
└── server_working pnmld.js

297 directories, 140 files

```

`public/index.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chatbot Gemini V3</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
```

`server/config/db.js`

```javascript
const mongoose = require('mongoose');
// const dotenv = require('dotenv'); // Removed dotenv

// dotenv.config(); // Removed dotenv

// Modified connectDB to accept the URI as an argument
const connectDB = async (mongoUri) => {
  if (!mongoUri) {
      console.error('MongoDB Connection Error: URI is missing.');
      process.exit(1);
  }
  try {
    // console.log(`Attempting MongoDB connection to: ${mongoUri}`); // Debug: Careful logging URI
    const conn = await mongoose.connect(mongoUri, {
      // Mongoose 6+ uses these defaults, so they are not needed
      // useNewUrlParser: true,
      // useUnifiedTopology: true,
      // serverSelectionTimeoutMS: 5000 // Example: Optional: Timeout faster
    });

    console.log(`✓ MongoDB Connected Successfully`); // Simpler success message
    return conn; // Return connection object if needed elsewhere
  } catch (error) {
    console.error('MongoDB Connection Error:', error.message);
    // Exit process with failure
    process.exit(1);
  }
};

module.exports = connectDB;

```

`server/middleware/authMiddleware.js`

```javascript
// server/middleware/authMiddleware.js
const User = require('../models/User');

// TEMPORARY Authentication Middleware (INSECURE - for debugging only)
// Checks for 'X-User-ID' header and attaches user to req.user
const tempAuth = async (req, res, next) => {
    const userId = req.headers['x-user-id']; // Read custom header (lowercase)

    // console.log("TempAuth Middleware: Checking for X-User-ID:", userId); // Debug log

    if (!userId) {
        console.warn("TempAuth Middleware: Missing X-User-ID header.");
        // Send 401 immediately if header is missing
        return res.status(401).json({ message: 'Unauthorized: Missing User ID header' });
    }

    try {
        // Find user by the ID provided in the header
        // Ensure Mongoose is connected before this runs (handled by server.js)
        const user = await User.findById(userId).select('-password'); // Exclude password

        if (!user) {
            console.warn(`TempAuth Middleware: User not found for ID: ${userId}`);
            // Send 401 if user ID is provided but not found in DB
            return res.status(401).json({ message: 'Unauthorized: User not found' });
        }

        // Attach user object to the request
        req.user = user;
        // console.log("TempAuth Middleware: User attached:", req.user.username); // Debug log
        next(); // Proceed to the next middleware or route handler

    } catch (error) {
        console.error('TempAuth Middleware: Error fetching user:', error);
        // Handle potential invalid ObjectId format errors
        if (error.name === 'CastError' && error.kind === 'ObjectId') {
             return res.status(400).json({ message: 'Bad Request: Invalid User ID format' });
        }
        // Send 500 for other unexpected errors during auth check
        res.status(500).json({ message: 'Server error during temporary authentication' });
    }
};

// Export the temporary middleware
module.exports = { tempAuth };

```

`server/models/ChatHistory.js`

```javascript
const mongoose = require('mongoose');

const MessageSchema = new mongoose.Schema({
    role: {
        type: String,
        enum: ['user', 'model'], // Gemini roles
        required: true
    },
    parts: [{
        text: {
            type: String,
            required: true
        }
        // _id: false // Mongoose adds _id by default, can disable if truly not needed per part
    }],
    timestamp: {
        type: Date,
        default: Date.now
    }
}, { _id: false }); // Don't create separate _id for each message object in the array

const ChatHistorySchema = new mongoose.Schema({
    userId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true,
        index: true,
    },
    sessionId: {
        type: String,
        required: true,
        unique: true,
        index: true,
    },
    messages: [MessageSchema], // Array of message objects
    createdAt: {
        type: Date,
        default: Date.now,
    },
    updatedAt: {
        type: Date,
        default: Date.now,
    }
});

// Update `updatedAt` timestamp before saving any changes
ChatHistorySchema.pre('save', function (next) {
    if (this.isModified()) { // Only update if document changed
      this.updatedAt = Date.now();
    }
    next();
});

// Also update `updatedAt` on findOneAndUpdate operations if messages are modified
ChatHistorySchema.pre('findOneAndUpdate', function(next) {
  this.set({ updatedAt: new Date() });
  next();
});


const ChatHistory = mongoose.model('ChatHistory', ChatHistorySchema);

module.exports = ChatHistory;

```

`server/models/User.js`

```javascript
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const UserSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'Please provide a username'],
    unique: true,
    trim: true,
  },
  password: {
    type: String,
    required: [true, 'Please provide a password'],
    minlength: 6,
    select: false, // Explicitly prevent password from being returned by default
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});

// Password hashing middleware before saving
UserSchema.pre('save', async function (next) {
  // Only hash the password if it has been modified (or is new)
  if (!this.isModified('password')) {
    return next();
  }
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (err) {
    next(err);
  }
});

// Method to compare entered password with hashed password
// Ensure we fetch the password field when needed for comparison
UserSchema.methods.comparePassword = async function (candidatePassword) {
  // 'this.password' might be undefined due to 'select: false'
  // Fetch the user again including the password if needed, or ensure the calling context selects it
  // However, bcrypt.compare handles the comparison securely.
  // We assume 'this.password' is available in the context where comparePassword is called.
  if (!this.password) {
      // This scenario should be handled by the calling code (e.g., findOne().select('+password'))
      // Or by using a static method like findByCredentials
      console.error("Attempted to compare password, but password field was not loaded on the User object."); // Added more specific log
      throw new Error("Password field not available for comparison.");
  }
  // Use bcryptjs's compare function
  return await bcrypt.compare(candidatePassword, this.password);
};

// Ensure password is selected when finding user for login comparison
UserSchema.statics.findByCredentials = async function(username, password) {
    // Find user by username AND explicitly select the password field
    const user = await this.findOne({ username }).select('+password');
    if (!user) {
        console.log(`findByCredentials: User not found for username: ${username}`); // Debug log
        return null; // User not found
    }
    // Now 'user' object has the password field, safe to call comparePassword
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
        console.log(`findByCredentials: Password mismatch for username: ${username}`); // Debug log
        return null; // Password doesn't match
    }
    console.log(`findByCredentials: Credentials match for username: ${username}`); // Debug log
    // Return user object (password will still be selected here, but won't be sent in JSON response usually)
    return user;
};


const User = mongoose.model('User', UserSchema);

module.exports = User;

```

`server/rag_service/app.py`

```python
# server/rag_service/app.py

import os
import sys
from flask import Flask, request, jsonify

# Add server directory to sys.path
current_dir = os.path.dirname(os.path.abspath(__file__))
server_dir = os.path.dirname(current_dir)
sys.path.insert(0, server_dir) # Ensure rag_service can be imported

# Now import local modules AFTER adjusting sys.path
from rag_service import config
import rag_service.file_parser as file_parser
import rag_service.faiss_handler as faiss_handler
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s:%(lineno)d] - %(message)s')
logger = logging.getLogger(__name__)

app = Flask(__name__)

def create_error_response(message, status_code=500):
    logger.error(f"API Error Response ({status_code}): {message}")
    return jsonify({"error": message}), status_code

@app.route('/health', methods=['GET'])
def health_check():
    logger.info("\n--- Received request at /health ---")
    status_details = {
        "status": "error",
        "embedding_model_type": config.EMBEDDING_TYPE,
        "embedding_model_name": config.EMBEDDING_MODEL_NAME,
        "embedding_dimension": None,
        "sentence_transformer_load": None,
        "default_index_loaded": False,
        "default_index_vectors": 0,
        "default_index_dim": None,
        "message": ""
    }
    http_status_code = 503

    try:
        # Check Embedding Model
        model = faiss_handler.embedding_model
        if model is None:
            status_details["message"] = "Embedding model could not be initialized during startup."
            status_details["sentence_transformer_load"] = "Failed"
            raise RuntimeError(status_details["message"])
        else:
            status_details["sentence_transformer_load"] = "OK"
            try:
                 status_details["embedding_dimension"] = faiss_handler.get_embedding_dimension(model)
            except Exception as dim_err:
                 status_details["embedding_dimension"] = f"Error: {dim_err}"


        # Check Default Index
        if config.DEFAULT_INDEX_USER_ID in faiss_handler.loaded_indices:
            status_details["default_index_loaded"] = True
            default_index = faiss_handler.loaded_indices[config.DEFAULT_INDEX_USER_ID]
            if hasattr(default_index, 'index') and default_index.index:
                status_details["default_index_vectors"] = default_index.index.ntotal
                status_details["default_index_dim"] = default_index.index.d
            logger.info("Default index found in cache.")
        else:
            logger.info("Attempting to load default index for health check...")
            try:
                default_index = faiss_handler.load_or_create_index(config.DEFAULT_INDEX_USER_ID)
                status_details["default_index_loaded"] = True
                if hasattr(default_index, 'index') and default_index.index:
                    status_details["default_index_vectors"] = default_index.index.ntotal
                    status_details["default_index_dim"] = default_index.index.d
                logger.info("Default index loaded successfully during health check.")
            except Exception as index_load_err:
                logger.error(f"Health check failed to load default index: {index_load_err}", exc_info=True)
                status_details["message"] = f"Failed to load default index: {index_load_err}"
                status_details["default_index_loaded"] = False
                raise # Re-raise to indicate failure

        # Final Status
        status_details["status"] = "ok"
        status_details["message"] = "RAG service is running, embedding model accessible, default index loaded."
        http_status_code = 200
        logger.info("Health check successful.")

    except Exception as e:
        logger.error(f"--- Health Check Error ---", exc_info=True)
        if not status_details["message"]: # Avoid overwriting specific error messages
            status_details["message"] = f"Health check failed: {str(e)}"
        # Ensure status is error if exception occurred
        status_details["status"] = "error"
        http_status_code = 503 # Service unavailable if health check fails critically

    return jsonify(status_details), http_status_code


@app.route('/add_document', methods=['POST'])
def add_document():
    logger.info("\n--- Received request at /add_document ---")
    if not request.is_json:
        return create_error_response("Request must be JSON", 400)

    data = request.get_json()
    user_id = data.get('user_id')
    file_path = data.get('file_path')
    original_name = data.get('original_name')

    if not all([user_id, file_path, original_name]):
        return create_error_response("Missing required fields: user_id, file_path, original_name", 400)

    logger.info(f"Processing file: {original_name} for user: {user_id}")
    logger.info(f"File path: {file_path}")

    if not os.path.exists(file_path):
        return create_error_response(f"File not found at path: {file_path}", 404)

    try:
        # 1. Parse File
        text_content = file_parser.parse_file(file_path)
        if text_content is None:
            logger.warning(f"Skipping embedding for {original_name}: File type not supported or parsing failed.")
            return jsonify({"message": f"File type of '{original_name}' not supported for RAG or parsing failed.", "filename": original_name, "status": "skipped"}), 200

        if not text_content.strip():
            logger.warning(f"Skipping embedding for {original_name}: No text content found after parsing.")
            return jsonify({"message": f"No text content extracted from '{original_name}'.", "filename": original_name, "status": "skipped"}), 200

        # 2. Chunk Text
        documents = file_parser.chunk_text(text_content, original_name, user_id)
        if not documents:
            logger.warning(f"No chunks created for {original_name}. Skipping add.")
            return jsonify({"message": f"No text chunks generated for '{original_name}'.", "filename": original_name, "status": "skipped"}), 200

        # 3. Add to Index (faiss_handler now handles dimension checks/recreation)
        faiss_handler.add_documents_to_index(user_id, documents)

        logger.info(f"Successfully processed and added document: {original_name} for user: {user_id}")
        return jsonify({
            "message": f"Document '{original_name}' processed and added to index.",
            "filename": original_name,
            "chunks_added": len(documents),
            "status": "added"
        }), 200
    except Exception as e:
        # Log the specific error from faiss_handler if it raised one
        logger.error(f"--- Add Document Error for file '{original_name}' ---", exc_info=True)
        return create_error_response(f"Failed to process document '{original_name}': {str(e)}", 500)


@app.route('/query', methods=['POST'])
def query_index_route():
    logger.info("\n--- Received request at /query ---")
    if not request.is_json:
        return create_error_response("Request must be JSON", 400)

    data = request.get_json()
    user_id = data.get('user_id')
    query = data.get('query')
    k = data.get('k', 5) # Default to k=5 now

    if not user_id or not query:
        return create_error_response("Missing required fields: user_id, query", 400)

    logger.info(f"Querying for user: {user_id} with k={k}")
    # Avoid logging potentially sensitive query text in production
    logger.debug(f"Query text: '{query[:100]}...'")

    try:
        results = faiss_handler.query_index(user_id, query, k=k)

        formatted_results = []
        for doc, score in results:
            # --- SEND FULL CONTENT ---
            content = doc.page_content
            # --- (No snippet generation needed) ---

            formatted_results.append({
                "documentName": doc.metadata.get("documentName", "Unknown"),
                "score": float(score),
                "content": content, # Send the full content
                # Removed "content_snippet"
            })

        logger.info(f"Query successful for user {user_id}. Returning {len(formatted_results)} results.")
        return jsonify({"relevantDocs": formatted_results}), 200
    except Exception as e:
        logger.error(f"--- Query Error ---", exc_info=True)
        return create_error_response(f"Failed to query index: {str(e)}", 500)

if __name__ == '__main__':
    # Ensure base FAISS directory exists on startup
    try:
        faiss_handler.ensure_faiss_dir()
    except Exception as e:
        logger.critical(f"CRITICAL: Could not create FAISS base directory '{config.FAISS_INDEX_DIR}'. Exiting. Error: {e}", exc_info=True)
        sys.exit(1) # Exit if base dir cannot be created

    # Attempt to initialize embedding model on startup
    try:
        faiss_handler.get_embedding_model() # This also determines the dimension
        logger.info("Embedding model initialized successfully on startup.")
    except Exception as e:
        logger.error(f"CRITICAL: Embedding model failed to initialize on startup: {e}", exc_info=True)
        logger.error("Endpoints requiring embeddings (/add_document, /query) will fail.")
        # Decide if you want to exit or run in a degraded state
        sys.exit(1) # Exit if embedding model fails - essential service

    # Attempt to load/check the default index on startup
    try:
        faiss_handler.load_or_create_index(config.DEFAULT_INDEX_USER_ID) # This checks/creates/validates dimension
        logger.info(f"Default index '{config.DEFAULT_INDEX_USER_ID}' loaded/checked/created on startup.")
    except Exception as e:
        logger.warning(f"Warning: Could not load/create default index '{config.DEFAULT_INDEX_USER_ID}' on startup: {e}", exc_info=True)
        # Don't necessarily exit, but log clearly. Queries might only use user indices.

    # Start Flask App
    port = config.RAG_SERVICE_PORT
    logger.info(f"--- Starting RAG service ---")
    logger.info(f"Listening on: http://0.0.0.0:{port}")
    logger.info(f"Using Embedding: {config.EMBEDDING_TYPE} ({config.EMBEDDING_MODEL_NAME})")
    try:
        logger.info(f"Embedding Dimension: {faiss_handler.get_embedding_dimension(faiss_handler.embedding_model)}")
    except: pass # Dimension already logged or failed earlier
    logger.info(f"FAISS Index Path: {config.FAISS_INDEX_DIR}")
    logger.info("-----------------------------")
    # Use waitress or gunicorn for production instead of Flask's development server
    app.run(host='0.0.0.0', port=port, debug=os.getenv('FLASK_DEBUG') == '1')

```

`server/rag_service/config.py`

```python
# server/rag_service/config.py
import os
import sys

# --- Determine Server Directory ---
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
SERVER_DIR = os.path.abspath(os.path.join(CURRENT_DIR, '..')) # Path to the 'server' directory
print(f"[rag_service/config.py] Determined SERVER_DIR: {SERVER_DIR}")

# --- Embedding Model Configuration ---
# Switch to Sentence Transformer
EMBEDDING_TYPE = 'sentence-transformer'
# Specify the model name (make sure you have internet access for download on first run)
# Or choose another model compatible with sentence-transformers library
# EMBEDDING_MODEL_NAME_ST = os.getenv('SENTENCE_TRANSFORMER_MODEL', 'BAAI/bge-large-en-v1.5')
EMBEDDING_MODEL_NAME_ST = os.getenv('SENTENCE_TRANSFORMER_MODEL', 'mixedbread-ai/mxbai-embed-large-v1')
# EMBEDDING_MODEL_NAME_ST = os.getenv('SENTENCE_TRANSFORMER_MODEL', 'e5-large-v2')
EMBEDDING_MODEL_NAME = EMBEDDING_MODEL_NAME_ST
print(f"Using Sentence Transformer model: {EMBEDDING_MODEL_NAME}")

# --- FAISS Configuration ---
FAISS_INDEX_DIR = os.path.join(SERVER_DIR, 'faiss_indices')
DEFAULT_ASSETS_DIR = os.path.join(SERVER_DIR, 'default_assets', 'engineering')
DEFAULT_INDEX_USER_ID = '__DEFAULT__'

# --- Text Splitting Configuration ---
CHUNK_SIZE = 512#1000
CHUNK_OVERLAP = 100#150

# --- API Configuration ---
RAG_SERVICE_PORT = int(os.getenv('RAG_SERVICE_PORT', 5002))

# --- Print effective configuration ---
print(f"FAISS Index Directory: {FAISS_INDEX_DIR}")
print(f"Default Assets Directory (for default.py): {DEFAULT_ASSETS_DIR}")
print(f"RAG Service Port: {RAG_SERVICE_PORT}")
print(f"Default Index User ID: {DEFAULT_INDEX_USER_ID}")
print(f"Chunk Size: {CHUNK_SIZE}, Chunk Overlap: {CHUNK_OVERLAP}")



```

`server/rag_service/default.py`

```python
import os
import logging
import sys
import traceback

# --- Path Setup ---
current_dir = os.path.dirname(os.path.abspath(__file__))
server_dir = os.path.dirname(current_dir)
project_root_dir = os.path.dirname(server_dir)
sys.path.insert(0, server_dir)
# --- End Path Setup ---

try:
    from rag_service import config
    from rag_service import faiss_handler
    from rag_service import file_parser
except ImportError as e:
     print("ImportError:", e)
     print("Failed to import modules. Ensure the script is run correctly relative to the project structure.")
     print("Current sys.path:", sys.path)
     exit(1)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s'
)
logger = logging.getLogger(__name__)


class DefaultVectorDBBuilder:
    def __init__(self):
        logger.info("Initializing embedding model...")
        try:
            # Use SentenceTransformer as configured in config.py
            self.embed_model = faiss_handler.get_embedding_model()
            if self.embed_model is None:
                 raise RuntimeError("Failed to initialize Sentence Transformer embedding model.")
        except Exception as e:
            logger.error(f"Fatal error initializing embedding model: {e}", exc_info=True)
            raise

        self.chunk_size = config.CHUNK_SIZE
        self.chunk_overlap = config.CHUNK_OVERLAP

        self.default_docs_dir = config.DEFAULT_ASSETS_DIR
        self.index_dir = config.FAISS_INDEX_DIR
        self.default_user_id = config.DEFAULT_INDEX_USER_ID

        self.default_index_user_path = faiss_handler.get_user_index_path(self.default_user_id)
        self.index_file_path = os.path.join(self.default_index_user_path, "index.faiss")
        self.pkl_file_path = os.path.join(self.default_index_user_path, "index.pkl")

        try:
            faiss_handler.ensure_faiss_dir()
            os.makedirs(self.default_index_user_path, exist_ok=True)
        except Exception as e:
             logger.error(f"Failed to create necessary directories: {e}")
             raise

        logger.info(f"Default assets directory: {self.default_docs_dir}")
        logger.info(f"Default index directory: {self.default_index_user_path}")


    def create_default_index(self, force_rebuild=True): # Keep force_rebuild flag
        """Scans default assets, parses files, creates embeddings, and saves the FAISS index."""
        logger.info("--- Starting Default Index Creation ---")

        # --- Force Rebuild Logic ---
        if force_rebuild and (os.path.exists(self.index_file_path) or os.path.exists(self.pkl_file_path)):
            logger.warning(f"force_rebuild=True. Deleting existing default index files in {self.default_index_user_path}.")
            try:
                if os.path.exists(self.index_file_path): os.remove(self.index_file_path)
                if os.path.exists(self.pkl_file_path): os.remove(self.pkl_file_path)
                # Clear from cache if loaded
                if self.default_user_id in faiss_handler.loaded_indices:
                    del faiss_handler.loaded_indices[self.default_user_id]
                logger.info("Removed existing default index files and cleared cache.")
            except OSError as e:
                logger.error(f"Error removing existing index files: {e}")
                return False # Stop if we can't remove old files
        elif not force_rebuild and (os.path.exists(self.index_file_path) or os.path.exists(self.pkl_file_path)):
             logger.info("Default index already exists and force_rebuild=False. Skipping creation.")
             # Try loading it to confirm validity
             try:
                 faiss_handler.load_or_create_index(self.default_user_id)
                 logger.info("Existing default index loaded successfully.")
                 return True
             except Exception as load_err:
                 logger.error(f"Failed to load existing default index: {load_err}. Consider running with force_rebuild=True.")
                 return False


        # --- Process Documents ---
        all_documents = []
        files_processed = 0
        files_skipped = 0

        logger.info(f"Scanning for processable files in: {self.default_docs_dir}")
        if not os.path.isdir(self.default_docs_dir):
            logger.error(f"Default assets directory not found: {self.default_docs_dir}")
            return False

        for root, _, files in os.walk(self.default_docs_dir):
            for filename in files:
                file_path = os.path.join(root, filename)
                # logger.debug(f"Found file: {filename}")
                try:
                    text_content = file_parser.parse_file(file_path)
                    if text_content and text_content.strip():
                        langchain_docs = file_parser.chunk_text(
                            text_content, filename, self.default_user_id
                        )
                        if langchain_docs:
                            all_documents.extend(langchain_docs)
                            files_processed += 1
                            logger.info(f"Parsed and chunked: {filename} ({len(langchain_docs)} chunks)")
                        else:
                            logger.warning(f"Skipped {filename}: No chunks generated.")
                            files_skipped += 1
                    else:
                        logger.warning(f"Skipped {filename}: No text content or unsupported type.")
                        files_skipped += 1
                except Exception as e:
                    logger.error(f"Error processing file {filename}: {e}")
                    traceback.print_exc()
                    files_skipped += 1

        if not all_documents:
            logger.error(f"No processable documents found or generated in {self.default_docs_dir}. Cannot create index.")
            # Still create an empty index structure if the directory was valid
            try:
                 logger.info("Creating an empty index structure as no documents were found.")
                 faiss_handler.load_or_create_index(self.default_user_id) # Creates empty index
                 logger.info("Empty default index created successfully.")
                 return True # Success, but empty
            except Exception as empty_create_err:
                 logger.error(f"Failed to create empty index structure: {empty_create_err}", exc_info=True)
                 return False


        logger.info(f"Total files processed: {files_processed}, skipped: {files_skipped}")
        logger.info(f"Creating embeddings and adding {len(all_documents)} total chunks to index...")

        try:
            # The load_or_create_index function will handle creating the empty structure
            # if it doesn't exist (or after deletion if force_rebuild=True)
            logger.info("Ensuring FAISS index structure exists...")
            index_instance = faiss_handler.load_or_create_index(self.default_user_id)

            logger.info(f"Adding {len(all_documents)} documents to the default index '{self.default_user_id}'...")
            # Use the updated handler function which now manages IDs correctly
            faiss_handler.add_documents_to_index(self.default_user_id, all_documents)

            # Verify save occurred
            if not os.path.exists(self.index_file_path) or not os.path.exists(self.pkl_file_path):
                 logger.error("Index files were not found after adding documents. Check permissions or disk space.")
                 return False

            logger.info(f"Successfully created/updated and saved default index ({self.default_user_id}) with {len(all_documents)} document chunks.")
            logger.info("--- Default Index Creation Finished ---")
            return True

        except Exception as e:
            logger.error(f"Failed during embedding or index creation: {e}", exc_info=True)
            logger.error("--- Default Index Creation Failed ---")
            return False

def main():
    print("--- Running Default Index Builder ---")
    try:
        builder = DefaultVectorDBBuilder()
    except Exception as init_err:
        print(f"FATAL: Failed to initialize builder: {init_err}")
        sys.exit(1)

    if not os.path.isdir(builder.default_docs_dir):
         logger.error(f"Default assets directory '{builder.default_docs_dir}' is missing.")
         sys.exit(1)

    # --- Always force rebuild as requested ---
    force = True
    logger.info(f"Starting index creation (force_rebuild={force})...")
    if not builder.create_default_index(force_rebuild=force):
        logger.error("Index creation process failed.")
        sys.exit(1)
    else:
        logger.info("Default index creation process completed successfully.")
        sys.exit(0)

if __name__ == "__main__":
    main()

```

`server/rag_service/faiss_handler.py`

```python
# server/rag_service/faiss_handler.py

import os
import faiss
from langchain_community.vectorstores import FAISS
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_core.embeddings import Embeddings as LangchainEmbeddings
from langchain_core.documents import Document as LangchainDocument
from langchain_community.docstore import InMemoryDocstore
from rag_service import config
import numpy as np
import time
import logging
import pickle
import uuid
import shutil # Import shutil for removing directories

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s')
handler.setFormatter(formatter)
if not logger.hasHandlers():
    logger.addHandler(handler)

embedding_model: LangchainEmbeddings | None = None
loaded_indices = {}
_embedding_dimension = None # Cache the dimension

def get_embedding_dimension(embedder: LangchainEmbeddings) -> int:
    """Gets and caches the embedding dimension."""
    global _embedding_dimension
    if _embedding_dimension is None:
        try:
            logger.info("Determining embedding dimension...")
            dummy_embedding = embedder.embed_query("dimension_check")
            dimension = len(dummy_embedding)
            if not isinstance(dimension, int) or dimension <= 0:
                raise ValueError(f"Invalid embedding dimension obtained: {dimension}")
            _embedding_dimension = dimension
            logger.info(f"Detected embedding dimension: {_embedding_dimension}")
        except Exception as e:
            logger.error(f"CRITICAL ERROR determining embedding dimension: {e}", exc_info=True)
            raise RuntimeError(f"Failed to determine embedding dimension: {e}")
    return _embedding_dimension

def get_embedding_model():
    global embedding_model
    if embedding_model is None:
        if config.EMBEDDING_TYPE == 'sentence-transformer':
            logger.info(f"Initializing HuggingFace Embeddings for Sentence Transformer (Model: {config.EMBEDDING_MODEL_NAME})")
            try:
                # Try CUDA first, fallback to CPU
                try:
                    if faiss.get_num_gpus() > 0:
                        device = 'cuda'
                        logger.info("CUDA detected. Using GPU for embeddings.")
                    else:
                        raise RuntimeError("No GPU found") # Force fallback
                except Exception:
                    device = 'cpu'
                    logger.warning("CUDA not available or GPU check failed. Using CPU for embeddings. This might be slow.")

                embedding_model = HuggingFaceEmbeddings(
                    model_name=config.EMBEDDING_MODEL_NAME,
                    model_kwargs={'device': device},
                    encode_kwargs={'normalize_embeddings': True} # Often recommended for cosine similarity / MIPS with FAISS
                )
                # Determine and cache dimension on successful load
                get_embedding_dimension(embedding_model)

                logger.info("Testing embedding function...")
                test_embedding_doc = embedding_model.embed_documents(["test document"])
                test_embedding_query = embedding_model.embed_query("test query")
                if not test_embedding_doc or not test_embedding_query:
                    raise ValueError("Embedding test failed, returned empty results.")
                logger.info(f"Embedding test successful.")

            except Exception as e:
                logger.error(f"Error loading HuggingFace Embeddings for '{config.EMBEDDING_MODEL_NAME}': {e}", exc_info=True)
                embedding_model = None
                raise RuntimeError(f"Failed to load embedding model: {e}")
        else:
            raise ValueError(f"Unsupported embedding type in config: {config.EMBEDDING_TYPE}. Expected 'sentence-transformer'.")
    return embedding_model

def get_user_index_path(user_id):
    safe_user_id = str(user_id).replace('.', '_').replace('/', '_').replace('\\', '_')
    user_dir = os.path.join(config.FAISS_INDEX_DIR, f"user_{safe_user_id}")
    return user_dir

def _delete_index_files(index_path, user_id):
    """Safely deletes index files for a user."""
    logger.warning(f"Deleting potentially incompatible index files for user '{user_id}' at {index_path}")
    try:
        if os.path.isdir(index_path):
            shutil.rmtree(index_path)
            logger.info(f"Successfully deleted directory: {index_path}")
        # If only loose files exist (less likely with save_local)
        index_file = os.path.join(index_path, "index.faiss")
        pkl_file = os.path.join(index_path, "index.pkl")
        if os.path.exists(index_file): os.remove(index_file)
        if os.path.exists(pkl_file): os.remove(pkl_file)
    except OSError as e:
        logger.error(f"Error deleting index files/directory for user '{user_id}' at {index_path}: {e}", exc_info=True)
        # Don't raise here, allow fallback to creating new index if possible

def load_or_create_index(user_id):
    global loaded_indices
    if user_id in loaded_indices:
        # **Even if cached, re-verify dimension on subsequent loads in case model changed**
        index = loaded_indices[user_id]
        embedder = get_embedding_model() # Ensure model is loaded
        current_dim = get_embedding_dimension(embedder)
        if hasattr(index, 'index') and index.index is not None and index.index.d != current_dim:
            logger.warning(f"Cached index for user '{user_id}' has dimension {index.index.d}, but current model has dimension {current_dim}. Discarding cache and forcing reload/recreate.")
            del loaded_indices[user_id] # Remove from cache
            # Fall through to load/create logic below
        else:
            logger.debug(f"Returning cached index for user '{user_id}'.")
            return index # Return cached and verified index

    index_path = get_user_index_path(user_id)
    index_file = os.path.join(index_path, "index.faiss")
    pkl_file = os.path.join(index_path, "index.pkl")

    embedder = get_embedding_model()
    if embedder is None:
        raise RuntimeError("Embedding model is not available.")
    current_embedding_dim = get_embedding_dimension(embedder)

    force_recreate = False
    if os.path.exists(index_file) and os.path.exists(pkl_file):
        logger.info(f"Attempting to load existing FAISS index for user '{user_id}' from {index_path}")
        try:
            start_time = time.time()
            # Temporarily load to check dimension
            index = FAISS.load_local(
                folder_path=index_path,
                embeddings=embedder,
                allow_dangerous_deserialization=True # Use with caution if index source isn't trusted
            )
            end_time = time.time()

            # --- CRITICAL DIMENSION CHECK ---
            if not hasattr(index, 'index') or index.index is None:
                 logger.warning(f"Loaded index for user '{user_id}' has no 'index' attribute or it's None. Forcing recreation.")
                 force_recreate = True
            elif index.index.d != current_embedding_dim:
                logger.warning(f"DIMENSION MISMATCH! Index for user '{user_id}' has dimension {index.index.d}, but current embedding model has dimension {current_embedding_dim}. Index is incompatible and will be recreated.")
                force_recreate = True
            elif index.index.ntotal == 0:
                logger.info(f"Loaded index for user '{user_id}' is empty (0 vectors). Will use it but note it's empty.")
                 # Not forcing recreate, just noting it's empty
            # --- END DIMENSION CHECK ---

            if force_recreate:
                _delete_index_files(index_path, user_id)
                # Don't return the incompatible index, fall through to create new one
            else:
                # If dimensions match and index is valid
                logger.info(f"Index for user '{user_id}' loaded successfully in {end_time - start_time:.2f} seconds. Dimension ({index.index.d}) matches. Contains {index.index.ntotal} vectors.")
                loaded_indices[user_id] = index
                return index

        except (pickle.UnpicklingError, EOFError, ModuleNotFoundError, AttributeError, ValueError) as load_err:
            logger.error(f"Error loading index for user '{user_id}' from {index_path}: {load_err}")
            logger.warning("Index files might be corrupted or incompatible. Attempting to delete and create a new index instead.")
            _delete_index_files(index_path, user_id)
            force_recreate = True # Ensure recreation logic runs
        except Exception as e:
            logger.error(f"Unexpected error loading index for user '{user_id}': {e}", exc_info=True)
            logger.warning("Attempting to delete and create a new index instead.")
            _delete_index_files(index_path, user_id)
            force_recreate = True # Ensure recreation logic runs

    # --- Create New Index Logic ---
    # This block runs if files didn't exist OR force_recreate is True
    logger.info(f"Creating new FAISS index structure for user '{user_id}' at {index_path} with dimension {current_embedding_dim}")
    try:
        # Ensure directory exists (it might have been deleted)
        os.makedirs(index_path, exist_ok=True)

        # Use the already determined dimension
        # Use IndexFlatIP if embeddings are normalized (recommended)
        faiss_index = faiss.IndexIDMap(faiss.IndexFlatIP(current_embedding_dim))
        # faiss_index = faiss.IndexIDMap(faiss.IndexFlatL2(current_embedding_dim)) # Use L2 if not normalized

        docstore = InMemoryDocstore({})
        index_to_docstore_id = {}

        index = FAISS(
            embedding_function=embedder,
            index=faiss_index,
            docstore=docstore,
            index_to_docstore_id=index_to_docstore_id,
            normalize_L2=False # Set True if using IndexFlatIP and normalized embeddings (which we are with encode_kwargs)
        )

        logger.info(f"Initialized empty index structure for user '{user_id}'.")
        loaded_indices[user_id] = index # Add to cache immediately
        save_index(user_id) # Save the empty structure
        logger.info(f"New empty index for user '{user_id}' created and saved.")
        return index
    except Exception as e:
        logger.error(f"CRITICAL ERROR creating new index for user '{user_id}': {e}", exc_info=True)
        if user_id in loaded_indices:
            del loaded_indices[user_id] # Clean up cache on failure
        # Attempt to clean up directory if creation failed badly
        _delete_index_files(index_path, user_id)
        raise RuntimeError(f"Failed to initialize FAISS index for user '{user_id}'")


def add_documents_to_index(user_id, documents: list[LangchainDocument]):
    if not documents:
        logger.warning(f"No documents provided to add for user '{user_id}'.")
        return

    try:
        index = load_or_create_index(user_id) # This now handles dimension checks/recreation
        embedder = get_embedding_model() # Ensure model is loaded

        # --- VERIFY DIMENSIONS AGAIN before adding (paranoid check) ---
        current_dim = get_embedding_dimension(embedder)
        if not hasattr(index, 'index') or index.index is None:
             logger.error(f"Index object for user '{user_id}' is invalid after load/create. Cannot add documents.")
             raise RuntimeError("Failed to get valid index structure.")
        if index.index.d != current_dim:
             logger.error(f"FATAL: Dimension mismatch just before adding documents for user '{user_id}'. Index: {index.index.d}, Model: {current_dim}. This shouldn't happen if load_or_create_index worked.")
             # Attempt recovery by deleting and trying again? Risky loop potential.
             _delete_index_files(get_user_index_path(user_id), user_id)
             if user_id in loaded_indices: del loaded_indices[user_id]
             raise RuntimeError(f"Inconsistent index dimension detected for user '{user_id}'. Please retry.")
        # --- END VERIFY ---

        logger.info(f"Adding {len(documents)} documents to index for user '{user_id}' (Index dim: {index.index.d})...")
        start_time = time.time()

        texts = [doc.page_content for doc in documents]
        metadatas = [doc.metadata for doc in documents]

        # Generate embeddings using the current model
        embeddings = embedder.embed_documents(texts)
        if not embeddings or len(embeddings) != len(texts):
             logger.error(f"Embedding generation failed or returned unexpected number of vectors for user '{user_id}'.")
             raise ValueError("Embedding generation failed.")
        if len(embeddings[0]) != current_dim:
             logger.error(f"Generated embeddings have incorrect dimension ({len(embeddings[0])}) for user '{user_id}', expected {current_dim}.")
             raise ValueError("Generated embedding dimension mismatch.")

        embeddings_np = np.array(embeddings, dtype=np.float32)

        # Generate unique IDs for FAISS
        ids = [str(uuid.uuid4()) for _ in texts]
        ids_np = np.array([uuid.UUID(id_).int & (2**63 - 1) for id_ in ids], dtype=np.int64)


        # Add embeddings and their corresponding IDs to the FAISS index
        index.index.add_with_ids(embeddings_np, ids_np)

        # Add the original documents and their metadata to the Langchain Docstore,
        # using the generated string UUIDs as keys.
        # Map the FAISS integer ID back to the string UUID used in the docstore.
        docstore_additions = {doc_id: doc for doc_id, doc in zip(ids, documents)}
        index.docstore.add(docstore_additions)
        for i, faiss_id in enumerate(ids_np):
            index.index_to_docstore_id[int(faiss_id)] = ids[i] # Map FAISS int ID -> string UUID

        end_time = time.time()
        logger.info(f"Successfully added {len(documents)} vectors/documents for user '{user_id}' in {end_time - start_time:.2f} seconds. Total vectors: {index.index.ntotal}")
        save_index(user_id)
    except Exception as e:
        logger.error(f"Error adding documents for user '{user_id}': {e}", exc_info=True)
        # Don't re-raise here if app.py handles it, but ensure logging is clear
        raise # Re-raise the exception so app.py can catch it and return 500

def query_index(user_id, query_text, k=3):
    all_results_with_scores = []
    embedder = get_embedding_model()

    if embedder is None:
        logger.error("Embedding model is not available for query.")
        raise ConnectionError("Embedding model is not available for query.")

    try:
        start_time = time.time()
        user_index = None # Initialize to None
        default_index = None # Initialize to None

        # Query User Index
        try:
            user_index = load_or_create_index(user_id) # Assign to user_index
            if hasattr(user_index, 'index') and user_index.index is not None and user_index.index.ntotal > 0:
                logger.info(f"Querying index for user: '{user_id}' (Dim: {user_index.index.d}, Vectors: {user_index.index.ntotal}) with k={k}")
                user_results = user_index.similarity_search_with_score(query_text, k=k)
                logger.info(f"User index '{user_id}' query returned {len(user_results)} results.")
                all_results_with_scores.extend(user_results)
            else:
                logger.info(f"Skipping query for user '{user_id}': Index is empty or invalid.")
        except FileNotFoundError:
            logger.warning(f"User index files for '{user_id}' not found on disk (might be first time). Skipping query for this index.")
        except RuntimeError as e:
            logger.error(f"Could not load or create user index for '{user_id}': {e}", exc_info=True)
        except Exception as e:
            logger.error(f"Unexpected error querying user index for '{user_id}': {e}", exc_info=True)


        # Query Default Index (if different from user_id)
        if user_id != config.DEFAULT_INDEX_USER_ID:
            try:
                default_index = load_or_create_index(config.DEFAULT_INDEX_USER_ID) # Assign to default_index
                if hasattr(default_index, 'index') and default_index.index is not None and default_index.index.ntotal > 0:
                    logger.info(f"Querying default index '{config.DEFAULT_INDEX_USER_ID}' (Dim: {default_index.index.d}, Vectors: {default_index.index.ntotal}) with k={k}")
                    default_results = default_index.similarity_search_with_score(query_text, k=k)
                    logger.info(f"Default index '{config.DEFAULT_INDEX_USER_ID}' query returned {len(default_results)} results.")
                    all_results_with_scores.extend(default_results)
                else:
                    logger.info(f"Skipping query for default index '{config.DEFAULT_INDEX_USER_ID}': Index is empty or invalid.")
            except FileNotFoundError:
                 logger.warning(f"Default index '{config.DEFAULT_INDEX_USER_ID}' not found on disk (run default.py?). Skipping query.")
            except RuntimeError as e:
                logger.error(f"Could not load or create default index '{config.DEFAULT_INDEX_USER_ID}': {e}", exc_info=True)
            except Exception as e:
                logger.error(f"Unexpected error querying default index '{config.DEFAULT_INDEX_USER_ID}': {e}", exc_info=True)

        query_time = time.time()
        logger.info(f"Completed all index queries in {query_time - start_time:.2f} seconds. Found {len(all_results_with_scores)} raw results.")

        # --- Deduplication and Sorting ---
        unique_results = {}
        for doc, score in all_results_with_scores:
            if not doc or not hasattr(doc, 'metadata') or not hasattr(doc, 'page_content'):
                logger.warning(f"Skipping invalid document object in results: {doc}")
                continue

            # Use the fallback content-based key
            content_key = f"{doc.metadata.get('documentName', 'Unknown')}_{doc.page_content[:200]}"
            unique_key = content_key # Use the content key directly

            # Add or update if the new score is better (lower for L2 distance / IP distance if normalized)
            if unique_key not in unique_results or score < unique_results[unique_key][1]:
                unique_results[unique_key] = (doc, score)

        # Sort by score (ascending for L2 distance / IP distance)
        sorted_results = sorted(unique_results.values(), key=lambda item: item[1])
        final_results = sorted_results[:k] # Get top k unique results

        logger.info(f"Returning {len(final_results)} unique results after filtering and sorting.")
        return final_results
    except Exception as e:
        logger.error(f"Error during query processing for user '{user_id}': {e}", exc_info=True)
        return [] # Return empty list on error


def save_index(user_id):
    global loaded_indices
    if user_id not in loaded_indices:
        logger.warning(f"Index for user '{user_id}' not found in cache, cannot save.")
        return

    index = loaded_indices[user_id]
    index_path = get_user_index_path(user_id)

    if not isinstance(index, FAISS) or not hasattr(index, 'index') or not hasattr(index, 'docstore') or not hasattr(index, 'index_to_docstore_id'):
        logger.error(f"Cannot save index for user '{user_id}': Invalid index object in cache.")
        return

    # Ensure the target directory exists before saving
    try:
        os.makedirs(index_path, exist_ok=True)
        logger.info(f"Saving FAISS index for user '{user_id}' to {index_path} (Vectors: {index.index.ntotal if hasattr(index.index, 'ntotal') else 'N/A'})...")
        start_time = time.time()
        # This saves index.faiss and index.pkl
        index.save_local(folder_path=index_path)
        end_time = time.time()
        logger.info(f"Index for user '{user_id}' saved successfully in {end_time - start_time:.2f} seconds.")
    except Exception as e:
        logger.error(f"Error saving FAISS index for user '{user_id}' to {index_path}: {e}", exc_info=True)

# --- ADD THIS FUNCTION DEFINITION BACK ---
def ensure_faiss_dir():
    """Ensures the base FAISS index directory exists."""
    try:
        os.makedirs(config.FAISS_INDEX_DIR, exist_ok=True)
        logger.info(f"Ensured FAISS base directory exists: {config.FAISS_INDEX_DIR}")
    except OSError as e:
        logger.error(f"Could not create FAISS base directory {config.FAISS_INDEX_DIR}: {e}")
        raise # Raise the error to prevent startup if dir creation fails
# --- END OF ADDED FUNCTION ---

```

`server/rag_service/file_parser.py`

```python
# server/rag_service/file_parser.py
import os
try:
    import pypdf
except ImportError:
    print("pypdf not found, PDF parsing will fail. Install with: pip install pypdf")
    pypdf = None # Set to None if not installed

try:
    from docx import Document as DocxDocument
except ImportError:
    print("python-docx not found, DOCX parsing will fail. Install with: pip install python-docx")
    DocxDocument = None

from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_core.documents import Document as LangchainDocument
from rag_service import config # Import from package
import logging

# Configure logger for this module
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO) # Or DEBUG for more details
handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
if not logger.hasHandlers():
    logger.addHandler(handler)


def parse_pdf(file_path):
    """Extracts text content from a PDF file using pypdf."""
    if not pypdf: return None # Check if library loaded
    text = ""
    try:
        reader = pypdf.PdfReader(file_path)
        num_pages = len(reader.pages)
        # logger.debug(f"Reading {num_pages} pages from PDF: {os.path.basename(file_path)}")
        for i, page in enumerate(reader.pages):
            try:
                page_text = page.extract_text()
                if page_text:
                    text += page_text + "\n" # Add newline between pages
            except Exception as page_err:
                 logger.warning(f"Error extracting text from page {i+1} of {os.path.basename(file_path)}: {page_err}")
        # logger.debug(f"Extracted {len(text)} characters from PDF.")
        return text.strip() if text.strip() else None # Return None if empty after stripping
    except FileNotFoundError:
        logger.error(f"PDF file not found: {file_path}")
        return None
    except pypdf.errors.PdfReadError as pdf_err:
        logger.error(f"Error reading PDF {os.path.basename(file_path)} (possibly corrupted or encrypted): {pdf_err}")
        return None
    except Exception as e:
        logger.error(f"Unexpected error parsing PDF {os.path.basename(file_path)}: {e}", exc_info=True)
        return None

def parse_docx(file_path):
    """Extracts text content from a DOCX file."""
    if not DocxDocument: return None # Check if library loaded
    try:
        doc = DocxDocument(file_path)
        text = "\n".join([para.text for para in doc.paragraphs if para.text.strip()])
        # logger.debug(f"Extracted {len(text)} characters from DOCX.")
        return text.strip() if text.strip() else None
    except Exception as e:
        logger.error(f"Error parsing DOCX {os.path.basename(file_path)}: {e}", exc_info=True)
        return None

def parse_txt(file_path):
    """Reads text content from a TXT file (or similar plain text like .py, .js)."""
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            text = f.read()
        # logger.debug(f"Read {len(text)} characters from TXT file.")
        return text.strip() if text.strip() else None
    except Exception as e:
        logger.error(f"Error parsing TXT {os.path.basename(file_path)}: {e}", exc_info=True)
        return None

# Add PPTX parsing (requires python-pptx)
try:
    from pptx import Presentation
    PPTX_SUPPORTED = True
    def parse_pptx(file_path):
        """Extracts text content from a PPTX file."""
        text = ""
        try:
            prs = Presentation(file_path)
            for slide in prs.slides:
                for shape in slide.shapes:
                    if hasattr(shape, "text"):
                        shape_text = shape.text.strip()
                        if shape_text:
                            text += shape_text + "\n" # Add newline between shape texts
            # logger.debug(f"Extracted {len(text)} characters from PPTX.")
            return text.strip() if text.strip() else None
        except Exception as e:
            logger.error(f"Error parsing PPTX {os.path.basename(file_path)}: {e}", exc_info=True)
            return None
except ImportError:
    PPTX_SUPPORTED = False
    logger.warning("python-pptx not installed. PPTX parsing will be skipped.")
    def parse_pptx(file_path):
        logger.warning(f"Skipping PPTX file {os.path.basename(file_path)} as python-pptx is not installed.")
        return None


def parse_file(file_path):
    """Parses a file based on its extension, returning text content or None."""
    _, ext = os.path.splitext(file_path)
    ext = ext.lower()
    logger.debug(f"Attempting to parse file: {os.path.basename(file_path)} (Extension: {ext})")

    if ext == '.pdf':
        return parse_pdf(file_path)
    elif ext == '.docx':
        return parse_docx(file_path)
    elif ext == '.pptx':
        return parse_pptx(file_path) # Use the conditional function
    elif ext in ['.txt', '.py', '.js', '.md', '.log', '.csv', '.html', '.xml', '.json']: # Expand text-like types
        return parse_txt(file_path)
    # Add other parsers here if needed (e.g., for .doc, .xls)
    elif ext == '.doc':
        # Requires antiword or similar external tool, more complex
        logger.warning(f"Parsing for legacy .doc files is not implemented: {os.path.basename(file_path)}")
        return None
    else:
        logger.warning(f"Unsupported file extension for parsing: {ext} ({os.path.basename(file_path)})")
        return None

def chunk_text(text, file_name, user_id):
    """Chunks text and creates Langchain Documents with metadata."""
    if not text or not isinstance(text, str):
        logger.warning(f"Invalid text input for chunking (file: {file_name}). Skipping.")
        return []

    # Use splitter configured in config.py
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=config.CHUNK_SIZE,
        chunk_overlap=config.CHUNK_OVERLAP,
        length_function=len,
        is_separator_regex=False, # Use default separators
        # separators=["\n\n", "\n", " ", ""] # Default separators
    )

    try:
        chunks = text_splitter.split_text(text)
        if not chunks:
             logger.warning(f"Text splitting resulted in zero chunks for file: {file_name}")
             return []

        documents = []
        for i, chunk in enumerate(chunks):
             # Ensure chunk is not just whitespace before creating Document
             if chunk and chunk.strip():
                 documents.append(
                     LangchainDocument(
                         page_content=chunk,
                         metadata={
                             'userId': user_id, # Store user ID
                             'documentName': file_name, # Store original filename
                             'chunkIndex': i # Store chunk index for reference
                         }
                     )
                 )
        if documents:
            logger.info(f"Split '{file_name}' into {len(documents)} non-empty chunks.")
        else:
            logger.warning(f"No non-empty chunks created for file: {file_name} after splitting.")
        return documents
    except Exception as e:
        logger.error(f"Error during text splitting for file {file_name}: {e}", exc_info=True)
        return [] # Return empty list on error

```

`server/rag_service/Readne.txt`

```
conda activate RAG
python server/rag_service/app.py
OR
python -m server.rag_service.app

For testing
curl -X POST -H "Content-Type: application/json" -d '{"user_id": "__DEFAULT__", "query": "machine learning"}' http://localhost:5002/query

for production
pip install gunicorn
gunicorn --bind 0.0.0.0:5002 server.rag_service.app:app


```

`server/rag_service/requirements.txt`

```
Flask
requests
sentence-transformers
faiss-cpu # or faiss-gpu
langchain
langchain-huggingface
pypdf
PyPDF2
python-docx
python-dotenv
ollama # Keep if using Ollama embeddings
python-pptx # Added for PPTX parsing
uuid


```

`server/rag_service/__init__.py`

```python

```

`server/routes/auth.js`

```javascript
// server/routes/auth.js
const express = require('express');
const { v4: uuidv4 } = require('uuid'); // For generating session IDs
const User = require('../models/User'); // Mongoose User model
require('dotenv').config();

const router = express.Router();

// --- @route   POST /api/auth/signup ---
// --- @desc    Register a new user ---
// --- @access  Public ---
router.post('/signup', async (req, res) => {
  const { username, password } = req.body;

  // Basic validation
  if (!username || !password) {
    return res.status(400).json({ message: 'Please provide username and password' });
  }
  if (password.length < 6) {
     return res.status(400).json({ message: 'Password must be at least 6 characters long' });
  }

  try {
    // Check if user already exists
    const existingUser = await User.findOne({ username });
    if (existingUser) {
      return res.status(400).json({ message: 'Username already exists' });
    }

    // Create new user (password hashing is handled by pre-save middleware in User model)
    const newUser = new User({ username, password });
    await newUser.save();

    // Generate a new session ID for the first login
    const sessionId = uuidv4();

    // Respond with user info (excluding password), and session ID
    // Note: Mongoose excludes 'select: false' fields by default after save() too
    res.status(201).json({
      _id: newUser._id, // Send user ID
      username: newUser.username,
      sessionId: sessionId, // Send session ID on successful signup/login
      message: 'User registered successfully',
    });

  } catch (error) {
    console.error('Signup Error:', error);
    // Handle potential duplicate key errors more gracefully if needed
    if (error.code === 11000) {
        return res.status(400).json({ message: 'Username already exists.' });
    }
    res.status(500).json({ message: 'Server error during signup' });
  }
});

// --- @route   POST /api/auth/signin ---
// --- @desc    Authenticate user (using custom static method) ---
// --- @access  Public ---
router.post('/signin', async (req, res) => {
  const { username, password } = req.body;

  if (!username || !password) {
    return res.status(400).json({ message: 'Please provide username and password' });
  }

  try {
    // *** CHANGE HERE: Use the static method from User model ***
    // This method finds the user AND selects the password field AND compares the password
    const user = await User.findByCredentials(username, password);

    // Check if the method returned a user (means credentials were valid)
    if (!user) {
      // findByCredentials returns null if user not found OR password doesn't match
      return res.status(401).json({ message: 'Invalid credentials' }); // Use generic message
    }

    // User authenticated successfully if we reached here

    // Generate a NEW session ID for this login session
    const sessionId = uuidv4();

    // Respond with user info (excluding password), and session ID
    // Even though 'user' has the password field selected from findByCredentials,
    // Mongoose's .toJSON() or spreading might still exclude it if schema default is select:false.
    // Explicitly create the response object.
    res.status(200).json({
      _id: user._id, // Send user ID
      username: user.username,
      sessionId: sessionId, // Send a *new* session ID on each successful login
      message: 'Login successful',
    });

  } catch (error) {
    // Log the specific error for debugging
    console.error('Signin Error:', error);
    // Check if the error came from the comparePassword method (e.g., bcrypt issue)
    if (error.message === "Password field not available for comparison.") {
        // This shouldn't happen if findByCredentials is used correctly, but good to check
        console.error("Developer Error: Password field was not selected before comparison attempt.");
        return res.status(500).json({ message: 'Internal server configuration error during signin.' });
    }
    res.status(500).json({ message: 'Server error during signin' });
  }
});


module.exports = router;

```

`server/routes/chat.js`

```javascript
// server/routes/chat.js
const express = require('express');
const axios = require('axios');
const { tempAuth } = require('../middleware/authMiddleware');
const ChatHistory = require('../models/ChatHistory');
const { v4: uuidv4 } = require('uuid');
const { generateContentWithHistory } = require('../services/geminiService');

const router = express.Router();

// --- Helper to call Python RAG Query Endpoint ---
async function queryPythonRagService(userId, query, k = 5) { // <<<--- INCREASED DEFAULT k HERE
    // Read URL from environment variable set during startup
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        console.error("PYTHON_RAG_SERVICE_URL is not set in environment. Cannot query RAG service.");
        throw new Error("RAG service configuration error.");
    }
    const queryUrl = `${pythonServiceUrl}/query`;
    console.log(`Querying Python RAG service for User ${userId} at ${queryUrl} with k=${k}`); // Log k value
    try {
        const response = await axios.post(queryUrl, {
            user_id: userId,
            query: query,
            k: k // Pass the requested k value
        }, { timeout: 30000 }); // 30 second timeout for query

        // Check for valid response structure (expecting "content" now)
        if (response.data && Array.isArray(response.data.relevantDocs)) {
            // Optional: Add a check here if needed to verify docs have 'content'
            // const hasContentField = response.data.relevantDocs.every(doc => doc && typeof doc.content === 'string');
            // if (!hasContentField && response.data.relevantDocs.length > 0) {
            //     console.warn(`Python RAG service returned docs missing the 'content' field.`);
            // }
            console.log(`Python RAG service returned ${response.data.relevantDocs.length} results.`);
            return response.data.relevantDocs;
        } else {
             console.warn(`Python RAG service returned unexpected data structure:`, response.data);
             return []; // Return empty on unexpected structure
        }
    } catch (error) {
        console.error(`Error querying Python RAG service for User ${userId}:`, error.response?.data || error.message);
        // Return empty allows chat to proceed without RAG context on error.
        return [];
    }
}


// --- @route   POST /api/chat/rag ---
// Use tempAuth middleware
router.post('/rag', tempAuth, async (req, res) => {
    const { message } = req.body;
    const userId = req.user._id.toString(); // req.user is guaranteed by tempAuth

    if (!message || typeof message !== 'string' || message.trim() === '') {
        return res.status(400).json({ message: 'Query message text required.' });
    }

    console.log(`>>> POST /api/chat/rag: User=${userId} (TEMP AUTH)`);

    try {
        // --- MODIFICATION START ---
        const kValue = 5; // Define the number of documents to retrieve
        // --- MODIFICATION END ---
        const relevantDocs = await queryPythonRagService(userId, message.trim(), kValue); // Pass kValue
        console.log(`<<< POST /api/chat/rag successful for User ${userId}. Found ${relevantDocs.length} docs.`);
        res.status(200).json({ relevantDocs }); // Send back the results

    } catch (error) {
        console.error(`!!! Error processing RAG query for User ${userId}:`, error);
        res.status(500).json({ message: "Failed to retrieve relevant documents." });
    }
});


// --- @route   POST /api/chat/message ---
// Use tempAuth middleware
router.post('/message', tempAuth, async (req, res) => {
    const { message, history, sessionId, systemPrompt, isRagEnabled, relevantDocs } = req.body;
    const userId = req.user._id.toString(); // req.user is guaranteed by tempAuth

    // --- Input Validations ---
    if (!message || typeof message !== 'string' || message.trim() === '') return res.status(400).json({ message: 'Message text required.' });
    if (!sessionId || typeof sessionId !== 'string') return res.status(400).json({ message: 'Session ID required.' });
    if (!Array.isArray(history)) return res.status(400).json({ message: 'Invalid history format.'});
    const useRAG = !!isRagEnabled; // Ensure boolean

    console.log(`>>> POST /api/chat/message: User=${userId}, Session=${sessionId}, RAG=${useRAG} (TEMP AUTH)`);

    let contextString = "";
    let citationHints = []; // Store hints for the LLM

    try {
        // --- Construct Context from RAG Results (if enabled and docs provided) ---
        // Use relevantDocs passed from the client (which called /rag first)
        if (useRAG && Array.isArray(relevantDocs) && relevantDocs.length > 0) {
            console.log(`   RAG Enabled: Processing ${relevantDocs.length} relevant documents provided by client.`);
            // Using the slightly relaxed prompt suggestion:
            contextString = "Answer the user's question based primarily on the following context documents.\nIf the context documents do not contain the necessary information to answer the question fully, clearly state what information is missing from the context *before* potentially providing an answer based on your general knowledge.\n\n--- Context Documents ---\n";
            relevantDocs.forEach((doc, index) => {
                // --- MODIFICATION START ---
                // Validate doc structure (check for 'content' now)
                if (!doc || typeof doc.documentName !== 'string' || typeof doc.content !== 'string') {
                    console.warn("   Skipping invalid/incomplete document in relevantDocs (missing 'content'):", doc);
                    return; // Skip this doc if structure is wrong
                }
                const docName = doc.documentName || 'Unknown Document';
                const score = doc.score !== undefined ? `(Rel. Score: ${(1 / (1 + doc.score)).toFixed(3)})` : '';
                const fullContent = doc.content; // Use the full content field
                // --- MODIFICATION END ---

                // Construct the context entry with full content
                contextString += `\n[${index + 1}] Source: ${docName} ${score}\nContent:\n${fullContent}\n---\n`; // Added separator for readability
                citationHints.push(`[${index + 1}] ${docName}`); // Hint for LLM citation
            });
            contextString += "\n--- End of Context ---\n\n";
            console.log(`   Constructed context string using full content. ${citationHints.length} valid docs used.`);
        } else {
            console.log(`   RAG Disabled or no relevant documents provided by client.`);
        }
        // --- End Context Construction ---

        // --- Prepare History & Current Message ---
        const historyForGeminiAPI = history.map(msg => ({
             role: msg.role,
             parts: msg.parts.map(part => ({ text: part.text || '' }))
        })).filter(msg => msg && msg.role && msg.parts && msg.parts.length > 0 && typeof msg.parts[0].text === 'string');

        // --- Construct Final User Query Text for Gemini ---
        let finalUserQueryText = "";
        if (useRAG && contextString) {
            const citationInstruction = `When referencing information ONLY from the context documents provided above, please cite the source using the format [Number] Document Name (e.g., ${citationHints.slice(0, 3).join(', ')}).`; // Show first few hints
            finalUserQueryText = `CONTEXT:\n${contextString}\nINSTRUCTIONS: ${citationInstruction}\n\nUSER QUESTION: ${message.trim()}`;
        } else {
            finalUserQueryText = message.trim();
        }

        const finalHistoryForGemini = [
            ...historyForGeminiAPI,
            { role: "user", parts: [{ text: finalUserQueryText }] }
        ];

        console.log(`   Calling Gemini API. History length: ${finalHistoryForGemini.length}. System Prompt: ${!!systemPrompt}`);

        // --- Call Gemini Service ---
        const geminiResponseText = await generateContentWithHistory(finalHistoryForGemini, systemPrompt);

        // --- Prepare Response ---
        let finalResponseText = geminiResponseText;
        const modelResponseMessage = {
            role: 'model',
            parts: [{ text: finalResponseText }],
            timestamp: new Date() // Add timestamp on the server
        };

        console.log(`<<< POST /api/chat/message successful for session ${sessionId}.`);
        res.status(200).json({ reply: modelResponseMessage });

    } catch (error) {
        // --- Error Handling ---
        console.error(`!!! Error processing chat message for session ${sessionId}:`, error);
        let statusCode = error.status || 500;
        let clientMessage = error.message || "Failed to get response from AI service.";
        // Don't expose excessive detail like stack traces
        if (error.originalError && statusCode === 500) {
            clientMessage = "An internal server error occurred while processing the AI response.";
        }
        res.status(statusCode).json({ message: clientMessage });
    }
});


// --- @route   POST /api/chat/history ---
// (No changes needed in this route)
router.post('/history', tempAuth, async (req, res) => {
    const { sessionId, messages } = req.body;
    const userId = req.user._id; // req.user guaranteed by tempAuth
    if (!sessionId) return res.status(400).json({ message: 'Session ID required to save history.' });
    if (!Array.isArray(messages)) return res.status(400).json({ message: 'Invalid messages format.' });

    try {
        const validMessages = messages.filter(m =>
            m && typeof m.role === 'string' &&
            Array.isArray(m.parts) && m.parts.length > 0 &&
            typeof m.parts[0].text === 'string' &&
            m.timestamp
        ).map(m => ({
            role: m.role,
            parts: [{ text: m.parts[0].text }],
            timestamp: m.timestamp
        }));

        if (validMessages.length !== messages.length) {
             console.warn(`Session ${sessionId}: Filtered out ${messages.length - validMessages.length} invalid messages during save.`);
        }
        if (validMessages.length === 0) {
             console.log(`Session ${sessionId}: No valid messages to save. Generating new session ID.`);
             const newSessionId = uuidv4();
             return res.status(200).json({
                 message: 'No history saved (empty chat). New session started.',
                 savedSessionId: null,
                 newSessionId: newSessionId
             });
        }

        const savedHistory = await ChatHistory.findOneAndUpdate(
            { sessionId: sessionId, userId: userId },
            { $set: { userId: userId, sessionId: sessionId, messages: validMessages, updatedAt: Date.now() } },
            { new: true, upsert: true, setDefaultsOnInsert: true }
        );
        const newSessionId = uuidv4();
        console.log(`History saved for session ${savedHistory.sessionId}. New session ID generated: ${newSessionId}`);
        res.status(200).json({
            message: 'Chat history saved successfully.',
            savedSessionId: savedHistory.sessionId,
            newSessionId: newSessionId
        });
    } catch (error) {
        console.error(`Error saving chat history for session ${sessionId}:`, error);
        if (error.name === 'ValidationError') return res.status(400).json({ message: "Validation Error saving history: " + error.message });
        if (error.code === 11000) return res.status(409).json({ message: "Conflict: Session ID might already exist unexpectedly." });
        res.status(500).json({ message: 'Failed to save chat history due to a server error.' });
    }
});


// --- @route   GET /api/chat/sessions ---
// (No changes needed in this route)
router.get('/sessions', tempAuth, async (req, res) => {
    const userId = req.user._id;
    try {
        const sessions = await ChatHistory.find({ userId: userId })
            .sort({ updatedAt: -1 })
            .select('sessionId createdAt updatedAt messages')
            .lean();

        const sessionSummaries = sessions.map(session => {
             const firstUserMessage = session.messages?.find(m => m.role === 'user');
             let preview = 'Chat Session';
             if (firstUserMessage?.parts?.[0]?.text) {
                 preview = firstUserMessage.parts[0].text.substring(0, 75);
                 if (firstUserMessage.parts[0].text.length > 75) {
                     preview += '...';
                 }
             }
             return {
                 sessionId: session.sessionId,
                 createdAt: session.createdAt,
                 updatedAt: session.updatedAt,
                 messageCount: session.messages?.length || 0,
                 preview: preview
             };
        });
        res.status(200).json(sessionSummaries);
    } catch (error) {
        console.error(`Error fetching chat sessions for user ${userId}:`, error);
        res.status(500).json({ message: 'Failed to retrieve chat sessions.' });
    }
});


// --- @route   GET /api/chat/session/:sessionId ---
// (No changes needed in this route)
router.get('/session/:sessionId', tempAuth, async (req, res) => {
    const userId = req.user._id;
    const { sessionId } = req.params;
    if (!sessionId) return res.status(400).json({ message: 'Session ID parameter is required.' });
    try {
        const session = await ChatHistory.findOne({ sessionId: sessionId, userId: userId }).lean();
        if (!session) return res.status(404).json({ message: 'Chat session not found or access denied.' });
        res.status(200).json(session);
    } catch (error) {
        console.error(`Error fetching chat session ${sessionId} for user ${userId}:`, error);
        res.status(500).json({ message: 'Failed to retrieve chat session details.' });
    }
});

module.exports = router;

```

`server/routes/files.js`

```javascript
// server/routes/files.js
const express = require('express');
const fs = require('fs').promises;
const path = require('path');
const { tempAuth } = require('../middleware/authMiddleware');

const router = express.Router();

const ASSETS_DIR = path.join(__dirname, '..', 'assets');
const BACKUP_DIR = path.join(__dirname, '..', 'backup_assets');

// --- Helper functions ---
const sanitizeUsernameForDir = (username) => {
    if (!username) return '';
    return username.replace(/[^a-zA-Z0-9_-]/g, '_');
};
const parseServerFilename = (filename) => {
    const match = filename.match(/^(\d+)-(.*?)(\.\w+)$/);
    if (match && match.length === 4) {
        return { timestamp: match[1], originalName: `${match[2]}${match[3]}`, extension: match[3] };
    }
     // Handle cases where the original name might not have an extension or parsing fails
    const ext = path.extname(filename);
    const base = filename.substring(0, filename.length - ext.length);
    const tsMatch = base.match(/^(\d+)-(.*)$/);
    if (tsMatch) {
        return { timestamp: tsMatch[1], originalName: `${tsMatch[2]}${ext}`, extension: ext };
    }
    // Fallback if no timestamp prefix found (less ideal)
    return { timestamp: null, originalName: filename, extension: path.extname(filename) };
};
const ensureDirExists = async (dirPath) => {
    try { await fs.mkdir(dirPath, { recursive: true }); }
    catch (error) { if (error.code !== 'EEXIST') { console.error(`Error creating dir ${dirPath}:`, error); throw error; } }
};
// --- End Helper Functions ---


// --- @route   GET /api/files ---
// Use tempAuth middleware
router.get('/', tempAuth, async (req, res) => {
    // req.user is guaranteed to exist here because of tempAuth middleware
    const sanitizedUsername = sanitizeUsernameForDir(req.user.username);
    if (!sanitizedUsername) {
        console.warn("GET /api/files: Invalid user identifier after sanitization.");
        return res.status(400).json({ message: 'Invalid user identifier.' });
    }

    const userAssetsDir = path.join(ASSETS_DIR, sanitizedUsername);
    const fileTypes = ['docs', 'images', 'code', 'others'];
    const userFiles = [];

    try {
        // Check if user directory exists
        try { await fs.access(userAssetsDir); }
        catch (e) {
             if (e.code === 'ENOENT') { return res.status(200).json([]); } // No dir, no files
             throw e; // Other error
        }

        // Scan subdirectories
        for (const type of fileTypes) {
            const typeDir = path.join(userAssetsDir, type);
            try {
                const filesInDir = await fs.readdir(typeDir);
                for (const filename of filesInDir) {
                    const filePath = path.join(typeDir, filename);
                    try {
                        const stats = await fs.stat(filePath);
                        if (stats.isFile()) {
                            const parsed = parseServerFilename(filename);
                            userFiles.push({
                                serverFilename: filename, originalName: parsed.originalName, type: type,
                                relativePath: path.join(type, filename).replace(/\\/g, '/'),
                                size: stats.size, lastModified: stats.mtime,
                            });
                        }
                    } catch (statError) { console.warn(`GET /api/files: Stat failed for ${filePath}:`, statError.message); }
                }
            } catch (err) { if (err.code !== 'ENOENT') { console.warn(`GET /api/files: Read failed for ${typeDir}:`, err.message); } }
        }

        userFiles.sort((a, b) => a.originalName.localeCompare(b.originalName));
        res.status(200).json(userFiles);

    } catch (error) {
        console.error(`!!! Error in GET /api/files for user ${sanitizedUsername}:`, error);
        res.status(500).json({ message: 'Failed to retrieve file list.' });
    }
});

// --- @route   PATCH /api/files/:serverFilename ---
// Use tempAuth middleware
router.patch('/:serverFilename', tempAuth, async (req, res) => {
    const { serverFilename } = req.params;
    const { newOriginalName } = req.body;
    const sanitizedUsername = sanitizeUsernameForDir(req.user.username); // req.user set by tempAuth

    // Validations
    if (!sanitizedUsername) return res.status(400).json({ message: 'Invalid user identifier.' });
    if (!serverFilename) return res.status(400).json({ message: 'Server filename parameter is required.' });
    if (!newOriginalName || typeof newOriginalName !== 'string' || newOriginalName.trim() === '') return res.status(400).json({ message: 'New file name is required.' });
    if (newOriginalName.includes('/') || newOriginalName.includes('\\') || newOriginalName.includes('..')) return res.status(400).json({ message: 'New file name contains invalid characters.' });

    try {
        const parsedOld = parseServerFilename(serverFilename);
        if (!parsedOld.timestamp) return res.status(400).json({ message: 'Invalid server filename format (missing timestamp prefix).' });

        // Find current file path
        let currentPath = null; let fileType = '';
        const fileTypesToSearch = ['docs', 'images', 'code', 'others'];
        for (const type of fileTypesToSearch) {
            const potentialPath = path.join(ASSETS_DIR, sanitizedUsername, type, serverFilename);
            try { await fs.access(potentialPath); currentPath = potentialPath; fileType = type; break; }
            catch (e) { if (e.code !== 'ENOENT') throw e; }
        }
        if (!currentPath) return res.status(404).json({ message: 'File not found or access denied.' });

        // Construct new path
        const newExt = path.extname(newOriginalName) || parsedOld.extension; // Preserve original ext if new one is missing
        const newBaseName = path.basename(newOriginalName, path.extname(newOriginalName)); // Get base name without extension
        const sanitizedNewBase = newBaseName.replace(/[^a-zA-Z0-9._-]/g, '_'); // Sanitize only the base name
        const finalNewOriginalName = `${sanitizedNewBase}${newExt}`; // Reconstruct original name
        const newServerFilename = `${parsedOld.timestamp}-${finalNewOriginalName}`; // Keep timestamp, use sanitized original name
        const newPath = path.join(ASSETS_DIR, sanitizedUsername, fileType, newServerFilename);

        // Perform rename
        await fs.rename(currentPath, newPath);

        res.status(200).json({
            message: 'File renamed successfully!', oldFilename: serverFilename,
            newFilename: newServerFilename, newOriginalName: finalNewOriginalName,
        });

    } catch (error) {
        console.error(`!!! Error in PATCH /api/files/${serverFilename} for user ${sanitizedUsername}:`, error);
        res.status(500).json({ message: 'Failed to rename the file.' });
    }
});


// --- @route   DELETE /api/files/:serverFilename ---
// Use tempAuth middleware
router.delete('/:serverFilename', tempAuth, async (req, res) => {
    const { serverFilename } = req.params;
    const sanitizedUsername = sanitizeUsernameForDir(req.user.username); // req.user set by tempAuth

    // Validations
    if (!sanitizedUsername) return res.status(400).json({ message: 'Invalid user identifier.' });
    if (!serverFilename) return res.status(400).json({ message: 'Server filename parameter is required.' });

    try {
        // Find current path
        let currentPath = null; let fileType = '';
        const fileTypesToSearch = ['docs', 'images', 'code', 'others'];
        for (const type of fileTypesToSearch) {
            const potentialPath = path.join(ASSETS_DIR, sanitizedUsername, type, serverFilename);
            try { await fs.access(potentialPath); currentPath = potentialPath; fileType = type; break; }
            catch (e) { if (e.code !== 'ENOENT') throw e; }
        }
        if (!currentPath) return res.status(404).json({ message: 'File not found or access denied.' });

        // Determine backup path
        const backupUserDir = path.join(BACKUP_DIR, sanitizedUsername, fileType);
        await ensureDirExists(backupUserDir);
        const backupPath = path.join(backupUserDir, serverFilename);

        // Perform move
        await fs.rename(currentPath, backupPath);

        res.status(200).json({ message: 'File deleted successfully (moved to backup).', filename: serverFilename });

    } catch (error) {
        console.error(`!!! Error in DELETE /api/files/${serverFilename} for user ${sanitizedUsername}:`, error);
        res.status(500).json({ message: 'Failed to delete the file.' });
    }
});

module.exports = router;

```

`server/routes/network.js`

```javascript
const express = require('express');
const router = express.Router();
const os = require('os');

function getAllIPs() {
    const interfaces = os.networkInterfaces();
    const ips = new Set(['localhost']); // Include localhost by default

    for (const [name, netInterface] of Object.entries(interfaces)) {
        // Skip loopback and potentially virtual interfaces if desired
        if (name.includes('lo') || name.toLowerCase().includes('virtual') || name.toLowerCase().includes('vmnet')) continue;

        for (const addr of netInterface) {
            // Focus on IPv4, non-internal addresses
            if (addr.family === 'IPv4' && !addr.internal) {
                ips.add(addr.address);
            }
        }
    }
    return Array.from(ips);
}

router.get('/ip', (req, res) => {
    res.json({
        ips: getAllIPs(),
        // req.ip might be less reliable behind proxies, but can be included
        // currentRequestIp: req.ip
    });
});

module.exports = router;

```

`server/routes/syllabus.js`

```javascript
// server/routes/syllabus.js
const express = require('express');
const fs = require('fs').promises;
const path = require('path');
const { tempAuth } = require('../middleware/authMiddleware'); // Protect the route

const router = express.Router();
const SYLLABI_DIR = path.join(__dirname, '..', 'syllabi');

// --- @route   GET /api/syllabus/:subjectId ---
// --- @desc    Get syllabus content for a specific subject ---
// --- @access  Private (requires auth) ---
router.get('/:subjectId', tempAuth, async (req, res) => {
    const { subjectId } = req.params;

    // Basic sanitization: Allow only alphanumeric and underscores
    // Prevents directory traversal (e.g., ../../etc/passwd)
    const sanitizedSubjectId = subjectId.replace(/[^a-zA-Z0-9_]/g, '');

    if (!sanitizedSubjectId || sanitizedSubjectId !== subjectId) {
        console.warn(`Syllabus request rejected due to invalid characters: ${subjectId}`);
        return res.status(400).json({ message: 'Invalid subject identifier format.' });
    }

    const filePath = path.join(SYLLABI_DIR, `${sanitizedSubjectId}.md`);

    try {
        // Check if file exists first (more specific error)
        await fs.access(filePath);

        // Read the file content
        const content = await fs.readFile(filePath, 'utf-8');

        res.status(200).json({ syllabus: content });

    } catch (error) {
        if (error.code === 'ENOENT') {
            console.warn(`Syllabus file not found: ${filePath}`);
            return res.status(404).json({ message: `Syllabus for '${subjectId}' not found.` });
        } else {
            console.error(`Error reading syllabus file ${filePath}:`, error);
            return res.status(500).json({ message: 'Server error retrieving syllabus.' });
        }
    }
});

module.exports = router;

```

`server/routes/upload.js`

```javascript
// server/routes/upload.js
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const axios = require('axios');
const { tempAuth } = require('../middleware/authMiddleware');

const router = express.Router();

// --- Constants ---
const UPLOAD_DIR = path.join(__dirname, '..', 'assets');
const MAX_FILE_SIZE = 20 * 1024 * 1024; // 20 MB

// Define allowed types by mimetype and extension (lowercase)
// Mapping mimetype to subfolder name
const allowedMimeTypes = {
    // Documents -> 'docs'
    'application/pdf': 'docs',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docs', // .docx
    'application/msword': 'docs', // .doc (Might be less reliable mimetype)
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'docs', // .pptx
    'application/vnd.ms-powerpoint': 'docs', // .ppt (Might be less reliable mimetype)
    'text/plain': 'docs', // .txt
    // Code -> 'code'
    'text/x-python': 'code', // .py
    'application/javascript': 'code', // .js
    'text/javascript': 'code', // .js (alternative)
    'text/markdown': 'code', // .md
    'text/html': 'code', // .html
    'application/xml': 'code', // .xml
    'text/xml': 'code', // .xml
    'application/json': 'code', // .json
    'text/csv': 'code', // .csv
    // Images -> 'images'
    'image/jpeg': 'images',
    'image/png': 'images',
    'image/bmp': 'images',
    'image/gif': 'images',
    // Add more specific types if needed, otherwise they fall into 'others'
};
// Define allowed extensions (lowercase) - This is a secondary check
const allowedExtensions = [
    '.pdf', '.docx', '.doc', '.pptx', '.ppt', '.txt',
    '.py', '.js', '.md', '.html', '.xml', '.json', '.csv', '.log', // Added .log
    '.jpg', '.jpeg', '.png', '.bmp', '.gif'
];

// --- Multer Config ---
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        // tempAuth middleware ensures req.user exists here
        if (!req.user || !req.user.username) {
            // This should ideally not happen if tempAuth works correctly
            console.error("Multer Destination Error: User context missing after auth middleware.");
            return cb(new Error("Authentication error: User context not found."));
        }
        const sanitizedUsername = req.user.username.replace(/[^a-zA-Z0-9_-]/g, '_');
        const fileMimeType = file.mimetype.toLowerCase();

        // Determine subfolder based on mimetype, default to 'others'
        const fileTypeSubfolder = allowedMimeTypes[fileMimeType] || 'others';
        const destinationPath = path.join(UPLOAD_DIR, sanitizedUsername, fileTypeSubfolder);

        // Ensure the destination directory exists (use async for safety)
        fs.mkdir(destinationPath, { recursive: true }, (err) => {
             if (err) {
                 console.error(`Error creating destination path ${destinationPath}:`, err);
                 cb(err);
             } else {
                 cb(null, destinationPath);
             }
         });
    },
    filename: (req, file, cb) => {
        const timestamp = Date.now();
        const fileExt = path.extname(file.originalname).toLowerCase();
        // Sanitize base name: remove extension, replace invalid chars, limit length
        const sanitizedBaseName = path.basename(file.originalname, fileExt)
                                      .replace(/[^a-zA-Z0-9._-]/g, '_') // Allow letters, numbers, dot, underscore, hyphen
                                      .substring(0, 100); // Limit base name length
        const uniqueFilename = `${timestamp}-${sanitizedBaseName}${fileExt}`;
        cb(null, uniqueFilename);
    }
});

const fileFilter = (req, file, cb) => {
    // tempAuth middleware should run before this, ensuring req.user exists
    if (!req.user) {
         console.warn(`Upload Rejected (File Filter): User context missing.`);
         const error = new multer.MulterError('UNAUTHENTICATED'); // Custom code?
         error.message = `User not authenticated.`;
         return cb(error, false);
    }

    const fileExt = path.extname(file.originalname).toLowerCase();
    const mimeType = file.mimetype.toLowerCase();

    // Primary check: Mimetype must be in our known list OR extension must be allowed
    // Secondary check: Extension must be in the allowed list
    const isMimeTypeKnown = !!allowedMimeTypes[mimeType];
    const isExtensionAllowed = allowedExtensions.includes(fileExt);

    // Allow if (MIME type is known OR extension is explicitly allowed) AND extension is in the allowed list
    // This allows known MIME types even if extension isn't listed, and listed extensions even if MIME isn't known (e.g. text/plain for .log)
    // But we always require the extension itself to be in the allowed list for safety.
    // if ((isMimeTypeKnown || isExtensionAllowed) && isExtensionAllowed) {

    // Stricter: Allow only if BOTH mimetype is known AND extension is allowed
    if (isMimeTypeKnown && isExtensionAllowed) {
        cb(null, true); // Accept file
    } else {
        console.warn(`Upload Rejected (File Filter): User='${req.user.username}', File='${file.originalname}', MIME='${mimeType}', Ext='${fileExt}'. MimeKnown=${isMimeTypeKnown}, ExtAllowed=${isExtensionAllowed}`);
        const error = new multer.MulterError('LIMIT_UNEXPECTED_FILE');
        error.message = `Invalid file type or extension. Allowed extensions: ${allowedExtensions.join(', ')}`;
        cb(error, false); // Reject file
    }
};

const upload = multer({
    storage: storage,
    fileFilter: fileFilter,
    limits: { fileSize: MAX_FILE_SIZE }
});
// --- End Multer Config ---


// --- Function to call Python RAG service ---
async function triggerPythonRagProcessing(userId, filePath, originalName) {
    // Read URL from environment variable set during startup
    const pythonServiceUrl = process.env.PYTHON_RAG_SERVICE_URL;
    if (!pythonServiceUrl) {
        console.error("PYTHON_RAG_SERVICE_URL is not set in environment. Cannot trigger processing.");
        // Optionally: Delete the uploaded file if processing can't be triggered?
        // await fs.promises.unlink(filePath).catch(e => console.error(`Failed to delete unprocessed file ${filePath}: ${e}`));
        return { success: false, message: "RAG service URL not configured." }; // Indicate failure
    }
    const addDocumentUrl = `${pythonServiceUrl}/add_document`;
    console.log(`Triggering Python RAG processing for ${originalName} (User: ${userId}) at ${addDocumentUrl}`);
    try {
        // Send absolute path
        const response = await axios.post(addDocumentUrl, {
            user_id: userId,
            file_path: filePath, // Send the absolute path
            original_name: originalName
        }, { timeout: 300000 }); // 5 minute timeout for processing

        console.log(`Python RAG service response for ${originalName}:`, response.data);
        // Check response.data.status ('added' or 'skipped')
        if (response.data?.status === 'skipped') {
             console.warn(`Python RAG service skipped processing ${originalName}: ${response.data.message}`);
             return { success: true, status: 'skipped', message: response.data.message };
        } else if (response.data?.status === 'added') {
             return { success: true, status: 'added', message: response.data.message };
        } else {
             console.warn(`Unexpected response status from Python RAG service for ${originalName}: ${response.data?.status}`);
             return { success: false, message: `Unexpected RAG status: ${response.data?.status}` };
        }

    } catch (error) {
        const errorMsg = error.response?.data?.error || error.message || "Unknown RAG service error";
        console.error(`Error calling Python RAG service for ${originalName}:`, errorMsg);
        // Maybe delete the file if the call fails? Depends on retry logic.
        // await fs.promises.unlink(filePath).catch(e => console.error(`Failed to delete file ${filePath} after RAG call error: ${e}`));
        return { success: false, message: `RAG service call failed: ${errorMsg}` }; // Indicate failure
    }
}
// --- End Function ---


// --- Modified Upload Route ---
router.post('/', tempAuth, (req, res) => {
    // req.user guaranteed by tempAuth
    const uploader = upload.single('file'); // 'file' must match the key in FormData

    uploader(req, res, async function (err) {
        // Ensure req.user exists after middleware execution
        if (!req.user) {
             console.error("!!! Upload handler: req.user not found after tempAuth.");
             // Avoid sending detailed error to client
             return res.status(401).json({ message: "Authentication error during upload." });
        }
        const userId = req.user._id.toString(); // Get userId here

        // --- Handle Multer Errors ---
        if (err) {
            console.error(`!!! Error during upload middleware for user ${req.user.username}:`, err);
            if (err instanceof multer.MulterError) {
                let message = "File upload failed.";
                if (err.code === 'LIMIT_FILE_SIZE') message = `File too large. Max: ${Math.round(MAX_FILE_SIZE / 1024 / 1024)} MB.`;
                else if (err.code === 'LIMIT_UNEXPECTED_FILE') message = err.message || 'Invalid file type.';
                else if (err.code === 'UNAUTHENTICATED') message = err.message || 'Authentication required.';
                // Avoid exposing filesystem errors directly
                return res.status(400).json({ message });
            } else {
                // Handle other errors (e.g., filesystem errors from storage)
                return res.status(500).json({ message: "Server error during upload preparation." });
            }
        }

        // --- Handle No File Case ---
        if (!req.file) {
            // This case might happen if fileFilter rejected the file but didn't throw a MulterError handled above
            console.warn(`Upload request for User '${req.user.username}' completed, but req.file is missing (potentially filtered).`);
            // Check if filter error message exists
            const filterError = req.multerFilterError; // Check if filter attached an error
            return res.status(400).json({ message: filterError?.message || "No valid file received or file type rejected." });
        }

        // --- File Successfully Saved by Multer ---
        const { path: filePath, originalname: originalName, filename: serverFilename } = req.file;
        const absoluteFilePath = path.resolve(filePath); // Ensure absolute path

        console.log(`<<< POST /api/upload successful for User '${req.user.username}'. File: ${serverFilename}.`);
        console.log(`   Absolute path: ${absoluteFilePath}`);

        // --- Trigger Python processing asynchronously ---
        // No await here, let the response go back quickly
        triggerPythonRagProcessing(userId, absoluteFilePath, originalName)
            .then(ragResult => {
                if (!ragResult.success) {
                     console.error(`Background RAG processing failed for ${originalName} (User: ${userId}): ${ragResult.message}`);
                     // Optional: Implement a mechanism to notify the user later or mark the file as unprocessed.
                } else {
                     console.log(`Background RAG processing initiated/completed for ${originalName} (User: ${userId}). Status: ${ragResult.status}`);
                }
            })
            .catch(error => {
                 // Log errors from initiating the trigger itself (should be rare)
                 console.error(`Error initiating background Python RAG processing for ${originalName}:`, error);
            });

        // --- Respond Immediately to the Client ---
        res.status(200).json({
            message: "File uploaded successfully! Background processing started.",
            filename: serverFilename, // Send back the generated server filename
            originalname: originalName,
        });
    });
});

module.exports = router;

```

`server/server.js`

```javascript
// server/server.js
const express = require('express');
// const dotenv = require('dotenv'); // Removed dotenv
const cors = require('cors');
const path = require('path');
const { getLocalIPs } = require('./utils/networkUtils');
const fs = require('fs');
const axios = require('axios');
const os = require('os');
const mongoose = require('mongoose'); // Import mongoose for closing connection
const readline = require('readline').createInterface({ // For prompting
  input: process.stdin,
  output: process.stdout,
});

// --- Custom Modules ---
const connectDB = require('./config/db');
const { performAssetCleanup } = require('./utils/assetCleanup');

// --- Configuration Loading ---
// dotenv.config(); // Removed dotenv

// --- Configuration Defaults & Variables ---
const DEFAULT_PORT = 5001;
const DEFAULT_MONGO_URI = 'mongodb+srv://admin:root@cluster59.vjp7w.mongodb.net/chatbot?retryWrites=true&w=majority&appName=Cluster59'; // Default DB URI
const DEFAULT_PYTHON_RAG_URL = 'http://127.0.0.1:5002'; // Default RAG service URL

let port = process.env.PORT || DEFAULT_PORT; // Use environment variable PORT if set, otherwise default
let mongoUri = process.env.MONGO_URI || ''; // Use environment variable if set
let pythonRagUrl = process.env.PYTHON_RAG_SERVICE_URL || ''; // Use environment variable if set
let geminiApiKey = process.env.GEMINI_API_KEY || ''; // MUST be set via environment

// --- Express Application Setup ---
const app = express();

// --- Core Middleware ---
app.use(cors()); // Allows requests from frontend (potentially on different IPs in LAN)
app.use(express.json());

// --- Basic Root Route ---
app.get('/', (req, res) => res.send('Chatbot Backend API is running...'));

// --- API Route Mounting ---
app.use('/api/network', require('./routes/network')); // For IP info
app.use('/api/auth', require('./routes/auth'));
app.use('/api/chat', require('./routes/chat'));
app.use('/api/upload', require('./routes/upload'));
app.use('/api/files', require('./routes/files'));
app.use('/api/syllabus', require('./routes/syllabus')); // <-- ADD THIS LINE



// --- Centralized Error Handling Middleware ---
app.use((err, req, res, next) => {
    console.error("Unhandled Error:", err.stack || err);
    const statusCode = err.status || 500;
    let message = err.message || 'An internal server error occurred.';
    // Sanitize potentially sensitive error details in production
    if (process.env.NODE_ENV === 'production' && statusCode === 500) {
        message = 'An internal server error occurred.';
    }
    // Ensure response is JSON for API routes
    if (req.originalUrl.startsWith('/api/')) {
         return res.status(statusCode).json({ message: message });
    }
    // Fallback for non-API routes if any
    res.status(statusCode).send(message);
});

// --- Server Instance Variable ---
let server;

// --- Graceful Shutdown Logic ---
const gracefulShutdown = async (signal) => {
    console.log(`\n${signal} received. Shutting down gracefully...`);
    readline.close(); // Close readline interface
    try {
        // Close HTTP server first to stop accepting new connections
        if (server) {
            server.close(async () => {
                console.log('HTTP server closed.');
                // Close MongoDB connection
                try {
                    await mongoose.connection.close();
                    console.log('MongoDB connection closed.');
                } catch (dbCloseError) {
                    console.error("Error closing MongoDB connection:", dbCloseError);
                }
                process.exit(0); // Exit after server and DB are closed
            });
        } else {
             // If server wasn't assigned, try closing DB and exit
             try {
                 await mongoose.connection.close();
                 console.log('MongoDB connection closed.');
             } catch (dbCloseError) {
                 console.error("Error closing MongoDB connection:", dbCloseError);
             }
            process.exit(0);
        }

        // Force exit after timeout if server.close callback doesn't finish
        setTimeout(() => {
            console.error('Graceful shutdown timed out, forcing exit.');
            process.exit(1);
        }, 10000); // 10 seconds

    } catch (shutdownError) {
        console.error("Error during graceful shutdown initiation:", shutdownError);
        process.exit(1);
    }
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// --- RAG Service Health Check ---
async function checkRagService(url) {
    console.log(`\nChecking RAG service health at ${url}...`);
    try {
        const response = await axios.get(`${url}/health`, { timeout: 7000 }); // 7 second timeout
        if (response.status === 200 && response.data?.status === 'ok') {
            console.log('✓ RAG service is available and healthy.');
            console.log(`  Embedding: ${response.data.embedding_model_type} (${response.data.embedding_model_name})`);
            console.log(`  Default Index Loaded: ${response.data.default_index_loaded}`);
            if (response.data.message && response.data.message.includes("Warning:")) {
                 console.warn(`  RAG Health Warning: ${response.data.message}`);
            }
            return true;
        } else {
             console.warn(`! RAG service responded but status is not OK: ${response.status} - ${JSON.stringify(response.data)}`);
             return false;
        }
    } catch (error) {
        console.warn('! RAG service is not reachable.');
        if (error.code === 'ECONNREFUSED') {
             console.warn(`  Connection refused at ${url}. Ensure the RAG service (server/rag_service/app.py) is running.`);
        } else if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {
             console.warn(`  Connection timed out to ${url}. The RAG service might be slow to start or unresponsive.`);
        }
         else {
             console.warn(`  Error: ${error.message}`);
        }
        console.warn('  RAG features (document upload processing, context retrieval) will be unavailable.');
        return false;
    }
}

// --- Directory Structure Check (Simplified) ---
async function ensureServerDirectories() {
    const dirs = [
        path.join(__dirname, 'assets'),
        path.join(__dirname, 'backup_assets'),
        // Add other essential dirs if needed
    ];
    console.log("\nEnsuring server directories exist...");
    try {
        for (const dir of dirs) {
            // Check existence synchronously, create asynchronously
            if (!fs.existsSync(dir)) {
                await fs.promises.mkdir(dir, { recursive: true });
                console.log(`  Created directory: ${dir}`);
            } else {
                // console.log(`  Directory exists: ${dir}`); // Optional: be less verbose
            }
        }
        console.log("✓ Server directories checked/created.");
    } catch (error) {
        console.error('!!! Error creating essential server directories:', error);
        throw error; // Prevent server start if essential dirs fail
    }
}

// --- Prompt for Configuration ---
function askQuestion(query) {
    return new Promise(resolve => readline.question(query, resolve));
}

async function configureAndStart() {
    console.log("--- Starting Server Configuration ---");

    // 1. Gemini API Key Check
    if (!geminiApiKey) {
        console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        console.error("!!! FATAL: GEMINI_API_KEY environment variable is not set. !!!");
        console.error("!!! Please set it before running the server:               !!!");
        console.error("!!! export GEMINI_API_KEY='YOUR_API_KEY'                   !!!");
        console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        process.exit(1);
    } else {
        console.log("✓ GEMINI_API_KEY found.");
    }

    // 2. MongoDB URI
    if (!mongoUri) {
        const answer = await askQuestion(`Enter MongoDB URI or press Enter for default (${DEFAULT_MONGO_URI}): `);
        mongoUri = answer.trim() || DEFAULT_MONGO_URI;
    }
    console.log(`Using MongoDB URI: ${mongoUri}`);

    // 3. Python RAG Service URL
    if (!pythonRagUrl) {
        const answer = await askQuestion(`Enter Python RAG Service URL or press Enter for default (${DEFAULT_PYTHON_RAG_URL}): `);
        pythonRagUrl = answer.trim() || DEFAULT_PYTHON_RAG_URL;
    }
    console.log(`Using Python RAG Service URL: ${pythonRagUrl}`);

    // 4. Port (Optional override via prompt, primarily uses ENV or default)
    // You could add a prompt here if needed, but ENV variable is common practice
    console.log(`Node.js server will listen on port: ${port}`);

    readline.close(); // Close the prompt interface

    // --- Pass configuration to other modules (if needed) ---
    // We'll make connectDB and services read directly or pass via function calls
    process.env.MONGO_URI = mongoUri; // Set for db.js
    process.env.PYTHON_RAG_SERVICE_URL = pythonRagUrl; // Set for chat.js, upload.js
    // GEMINI_API_KEY is already in process.env

    console.log("--- Configuration Complete ---");

    // --- Proceed with Server Startup ---
    await startServer();
}


// --- Asynchronous Server Startup Function ---
async function startServer() {
    console.log("\n--- Starting Server Initialization ---");
    try {
        await ensureServerDirectories(); // Check/create assets, backup_assets dirs
        await connectDB(mongoUri); // Connect to MongoDB - Pass URI explicitly
        await performAssetCleanup(); // Backup existing assets, create fresh user folders
        await checkRagService(pythonRagUrl); // Check Python RAG service status

        const PORT = port; // Use the configured port
        const availableIPs = getLocalIPs(); // Get all local IPs

        server = app.listen(PORT, '0.0.0.0', () => { // Listen on all interfaces
            console.log('\n=== Node.js Server Ready ===');
            console.log(`🚀 Server listening on port ${PORT}`);
            console.log('   Access the application via these URLs (using common frontend ports):');
            const frontendPorts = [3000, 3001, 8080, 5173]; // Common React/Vite ports
            availableIPs.forEach(ip => {
                 frontendPorts.forEach(fp => {
                    console.log(`   - http://${ip}:${fp} (Frontend) -> Connects to Backend at http://${ip}:${PORT}`);
                 });
            });
            console.log('============================\n');
            console.log("💡 Hint: Client automatically detects backend IP based on how you access the frontend.");
            console.log(`   Ensure firewalls allow connections on port ${PORT} (Backend) and your frontend port.`);
            console.log("--- Server Initialization Complete ---");
        });

    } catch (error) {
        console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        console.error("!!! Failed to start Node.js server:", error.message);
        console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        process.exit(1); // Exit if initialization fails
    }
}

// --- Execute Configuration and Server Start ---
configureAndStart();

```

`server/services/.env`

```
GEMINI_API_KEY="AIzaSyDs2GE0ttB2Q93w5SsW03SKXb1edNMbdcU"
```

`server/services/geminiService.js`

```javascript
// server/services/geminiService.js
const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = require('@google/generative-ai');
require('dotenv').config(); // Removed dotenv

// Read API Key directly from environment variables
const API_KEY = process.env.GEMINI_API_KEY;
const MODEL_NAME = "gemini-1.5-flash"; // Or read from env: process.env.GEMINI_MODEL_NAME || "gemini-1.5-flash";

if (!API_KEY) {
    // This check is now primarily done in server.js before starting
    // But keep a safeguard here.
    console.error("FATAL ERROR: GEMINI_API_KEY is not available in the environment. Server should have exited.");
    // Throw an error instead of exiting here, let the caller handle it
    throw new Error("GEMINI_API_KEY is missing.");
}

const genAI = new GoogleGenerativeAI(API_KEY);

const baseGenerationConfig = {
    temperature: 0.7, // Moderate temperature for creative but grounded responses
    maxOutputTokens: 4096, // Adjust as needed, Flash model limit might be higher
    // topP: 0.9, // Example: Could add nucleus sampling
    // topK: 40,  // Example: Could add top-k sampling
};

// Stricter safety settings - adjust as needed for your use case
const baseSafetySettings = [
    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_ONLY_HIGH },
];

const generateContentWithHistory = async (chatHistory, systemPromptText = null, relevantDocs = []) => {
    try {
        if (!Array.isArray(chatHistory) || chatHistory.length === 0) {
             throw new Error("Chat history must be a non-empty array.");
        }
        // Gemini API requires history to end with a 'user' message for sendMessage
        if (chatHistory[chatHistory.length - 1].role !== 'user') {
            console.error("History for Gemini API must end with a 'user' role message.");
            // Attempt to fix by removing trailing non-user messages if any? Risky.
            // Or just throw error.
            throw new Error("Internal error: Invalid chat history sequence for API call.");
        }

        // --- Prepare Model Options ---
        const modelOptions = {
            model: MODEL_NAME,
            generationConfig: baseGenerationConfig,
            safetySettings: baseSafetySettings,
            // Add system instruction if provided
            ...(systemPromptText && typeof systemPromptText === 'string' && systemPromptText.trim() !== '' && {
                systemInstruction: {
                    // Gemini expects system instruction parts as an array
                    parts: [{ text: systemPromptText.trim() }]
                }
             })
        };
        const model = genAI.getGenerativeModel(modelOptions);


        // --- Prepare History for startChat ---
        // History for startChat should NOT include the latest user message
        const historyForStartChat = chatHistory.slice(0, -1)
            .map(msg => ({ // Ensure correct format
                 role: msg.role,
                 parts: msg.parts.map(part => ({ text: part.text || '' }))
            }))
            .filter(msg => msg.role && msg.parts && msg.parts.length > 0 && typeof msg.parts[0].text === 'string'); // Basic validation

        // --- Start Chat Session ---
        const chat = model.startChat({
            history: historyForStartChat,
        });

        // --- Prepare the message to send ---
        // Get the text from the last user message in the original history
        let lastUserMessageText = chatHistory[chatHistory.length - 1].parts[0].text;

        // Optional: Add a subtle hint for citation if RAG was used (Gemini might pick it up)
        // if (relevantDocs.length > 0) {
        //     const citationHint = ` (Remember to cite sources like ${relevantDocs.map((doc, i) => `[${i+1}] ${doc.documentName}`).slice(0,2).join(', ')} if applicable)`;
        //     lastUserMessageText += citationHint;
        // }

        console.log(`Sending message to Gemini. History length sent to startChat: ${historyForStartChat.length}. System Prompt Used: ${!!modelOptions.systemInstruction}`);
        // console.log("Last User Message Text Sent:", lastUserMessageText.substring(0, 200) + "..."); // Log truncated message

        // --- Send Message ---
        const result = await chat.sendMessage(lastUserMessageText);

        // --- Process Response ---
        const response = result.response;
        const candidate = response?.candidates?.[0];

        // --- Validate Response ---
        if (!candidate || candidate.finishReason === 'STOP' || candidate.finishReason === 'MAX_TOKENS') {
            // Normal completion or max tokens reached
            const responseText = candidate?.content?.parts?.[0]?.text;
            if (typeof responseText === 'string') {
                return responseText; // Success
            } else {
                 console.warn("Gemini response finished normally but text content is missing or invalid.", { finishReason: candidate?.finishReason, content: candidate?.content });
                 throw new Error("Received an empty or invalid response from the AI service.");
            }
        } else {
             // Handle blocked responses or other issues
             const finishReason = candidate?.finishReason || 'Unknown';
             const safetyRatings = candidate?.safetyRatings;
             console.warn("Gemini response was potentially blocked or had issues.", { finishReason, safetyRatings });

             let blockMessage = `AI response generation failed or was blocked.`;
             if (finishReason) blockMessage += ` Reason: ${finishReason}.`;
             if (safetyRatings) {
                const blockedCategories = safetyRatings.filter(r => r.blocked).map(r => r.category).join(', ');
                if (blockedCategories) {
                    blockMessage += ` Blocked Categories: ${blockedCategories}.`;
                }
             }

             const error = new Error(blockMessage);
             error.status = 400; // Treat as a bad request or policy issue
             throw error;
        }

    } catch (error) {
        console.error("Gemini API Call Error:", error?.message || error);
        // Improve error message for client
        let clientMessage = "Failed to get response from AI service.";
        if (error.message?.includes("API key not valid")) {
            clientMessage = "AI Service Error: Invalid API Key.";
        } else if (error.message?.includes("blocked")) {
            clientMessage = error.message; // Use the specific block message
        } else if (error.status === 400) {
             clientMessage = `AI Service Error: ${error.message}`;
        }

        const enhancedError = new Error(clientMessage);
        enhancedError.status = error.status || 500; // Keep original status if available
        enhancedError.originalError = error; // Attach original error if needed for server logs
        throw enhancedError;
    }
};

module.exports = { generateContentWithHistory };

```

`server/utils/assetCleanup.js`

```javascript
const fs = require('fs').promises; // Use fs.promises for async operations
const path = require('path');

// Define constants relative to this file's location (server/utils)
const ASSETS_DIR = path.join(__dirname, '..', 'assets'); // Go up one level to server/assets
const BACKUP_DIR = path.join(__dirname, '..', 'backup_assets'); // Go up one level to server/backup_assets
const FOLDER_TYPES = ['docs', 'images', 'code', 'others']; // Folders within each user's asset dir

/**
 * Moves existing user asset folders (docs, images, code, others) to a timestamped
 * backup location and recreates empty asset folders for each user on server startup.
 */
async function performAssetCleanup() {
    console.log("\n--- Starting Asset Cleanup ---");
    try {
        // Ensure backup base directory exists
        await fs.mkdir(BACKUP_DIR, { recursive: true });

        // List potential user directories in assets
        let userDirs = [];
        try {
            userDirs = await fs.readdir(ASSETS_DIR);
        } catch (err) {
            if (err.code === 'ENOENT') {
                console.log("Assets directory doesn't exist yet, creating it and skipping cleanup.");
                await fs.mkdir(ASSETS_DIR, { recursive: true }); // Ensure assets dir exists
                console.log("--- Finished Asset Cleanup (No existing assets found) ---");
                return; // Nothing to clean up
            }
            throw err; // Re-throw other errors accessing assets dir
        }

        if (userDirs.length === 0) {
             console.log("Assets directory is empty. Skipping backup/move operations.");
             console.log("--- Finished Asset Cleanup (No user assets found) ---");
             return;
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-'); // Create a safe timestamp string

        for (const userName of userDirs) {
            const userAssetPath = path.join(ASSETS_DIR, userName);
            const userBackupPathBase = path.join(BACKUP_DIR, userName);
            const userTimestampBackupPath = path.join(userBackupPathBase, `backup_${timestamp}`);

            try {
                // Check if the item in assets is actually a directory
                const stats = await fs.stat(userAssetPath);
                if (!stats.isDirectory()) {
                    console.log(`  Skipping non-directory item in assets: ${userName}`);
                    continue;
                }

                console.log(`  Processing assets for user: [${userName}]`);
                let backupDirCreated = false; // Track if backup dir was created for this user/run
                let movedSomething = false; // Track if anything was actually moved

                // Process each defined folder type (docs, images, etc.)
                for (const type of FOLDER_TYPES) {
                    const sourceTypePath = path.join(userAssetPath, type);
                    try {
                        // Check if the source type directory exists before trying to move
                        await fs.access(sourceTypePath);

                        // If source exists, ensure the timestamped backup directory is ready
                        if (!backupDirCreated) {
                            await fs.mkdir(userTimestampBackupPath, { recursive: true });
                            backupDirCreated = true;
                            // console.log(`    Created backup directory: ${userTimestampBackupPath}`);
                        }

                        // Define the destination path in the backup folder
                        const backupTypePath = path.join(userTimestampBackupPath, type);
                        // console.log(`    Moving ${sourceTypePath} to ${backupTypePath}`);
                        // Move the existing type folder to the backup location
                        await fs.rename(sourceTypePath, backupTypePath);
                        movedSomething = true;

                    } catch (accessErr) {
                        // Ignore error if the source directory doesn't exist (ENOENT)
                        if (accessErr.code !== 'ENOENT') {
                            console.error(`    Error accessing source folder ${sourceTypePath}:`, accessErr.message);
                        }
                        // If ENOENT, the folder doesn't exist, nothing to move.
                    }

                    // Always ensure the empty type directory exists in the main assets folder
                    try {
                        // console.log(`    Ensuring empty directory: ${sourceTypePath}`);
                        await fs.mkdir(sourceTypePath, { recursive: true });
                    } catch (mkdirErr) {
                         console.error(`    Failed to recreate directory ${sourceTypePath}:`, mkdirErr.message);
                    }
                } // End loop through FOLDER_TYPES

                 if (movedSomething) {
                     console.log(`  Finished backup for user [${userName}] to backup_${timestamp}`);
                 } else {
                     console.log(`  No existing asset types found to backup for user [${userName}]`);
                 }


            } catch (userDirStatErr) {
                 // Error checking if the item in assets is a directory
                 console.error(`Error processing potential user asset directory ${userAssetPath}:`, userDirStatErr.message);
            }
        } // End loop through userDirs

        console.log("--- Finished Asset Cleanup ---");

    } catch (error) {
        // Catch errors related to backup dir creation or reading the main assets dir
        console.error("!!! Critical Error during Asset Cleanup process:", error);
    }
}

// Export the function to be used elsewhere
module.exports = { performAssetCleanup };

```

`server/utils/networkUtils.js`

```javascript
const os = require('os');

function getLocalIPs() {
    const interfaces = os.networkInterfaces();
    const ips = new Set(['localhost']); // Include localhost

    for (const iface of Object.values(interfaces)) {
        for (const addr of iface) {
            // Include IPv4 non-internal addresses
            if (addr.family === 'IPv4' && !addr.internal) {
                ips.add(addr.address);
            }
        }
    }
    return Array.from(ips);
}

function getPreferredLocalIP() {
    const ips = getLocalIPs();
    // Prioritize non-localhost, non-link-local (169.254) IPs
    // Often 192.168.* or 10.* or 172.16-31.* are common private ranges
    return ips.find(ip => !ip.startsWith('169.254.') && ip !== 'localhost' && (ip.startsWith('192.168.') || ip.startsWith('10.') || ip.match(/^172\.(1[6-9]|2[0-9]|3[0-1])\./))) ||
           ips.find(ip => !ip.startsWith('169.254.') && ip !== 'localhost') || // Any other non-link-local
           'localhost'; // Fallback
}

module.exports = { getLocalIPs, getPreferredLocalIP };

```

`src/App.css`

```css
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f0f2f5; /* Consistent background */
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

.App {
  text-align: center;
}

/* Add any other global styles you need */

```

`src/App.js`

```javascript
// client/src/App.js
import React, { useState, useEffect, Suspense } from 'react';
import { BrowserRouter as Router, Route, Routes, Navigate } from 'react-router-dom';
import { ThemeProvider, createTheme, CircularProgress } from '@mui/material';

// Lazy load components to reduce initial bundle size
const AuthPage = React.lazy(() => import('./components/AuthPage'));
const ChatPage = React.lazy(() => import('./components/ChatPage'));

const darkTheme = createTheme({
  palette: {
    mode: 'dark',
    background: {
      default: '#1a1a1a',
      paper: '#2d2d2d',
    },
    primary: {
      main: '#90caf9',
    },
    text: {
      primary: '#ffffff',
      secondary: '#b3b3b3',
    }
  },
  components: {
    MuiCard: {
      styleOverrides: {
        root: {
          backgroundColor: '#2d2d2d',
          color: '#ffffff',
        }
      }
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundColor: '#2d2d2d',
          color: '#ffffff',
        }
      }
    }
  }
});

const LoadingFallback = () => (
    <div style={{ 
        display: 'flex', 
        justifyContent: 'center', 
        alignItems: 'center', 
        height: '100vh',
        backgroundColor: '#121212'
    }}>
        <CircularProgress />
    </div>
);

function App() {
    const [isAuthenticated, setIsAuthenticated] = useState(!!localStorage.getItem('userId'));

    useEffect(() => {
        const handleStorageChange = (event) => {
            if (event.key === 'userId') {
                const hasUserId = !!event.newValue;
                console.log("App Storage Listener: userId changed, setting isAuthenticated to", hasUserId);
                setIsAuthenticated(hasUserId);
            }
        };

        window.addEventListener('storage', handleStorageChange);

        return () => {
            window.removeEventListener('storage', handleStorageChange);
        };
    }, []);

    return (
        <ThemeProvider theme={darkTheme}>
            <Router>
                <div style={{ 
                    minHeight: '100vh',
                    backgroundColor: '#1a1a1a',
                    color: '#ffffff',
                    padding: '20px'
                }}>
                    <Suspense fallback={<LoadingFallback />}>
                        <Routes>
                            <Route
                                path="/login"
                                element={
                                    !isAuthenticated ? (
                                        <AuthPage setIsAuthenticated={setIsAuthenticated} />
                                    ) : (
                                        <Navigate to="/chat" replace />
                                    )
                                }
                            />

                            <Route
                                path="/chat"
                                element={
                                    isAuthenticated ? (
                                        <ChatPage setIsAuthenticated={setIsAuthenticated} />
                                    ) : (
                                        <Navigate to="/login" replace />
                                    )
                                }
                            />

                            <Route
                                path="/"
                                element={
                                    isAuthenticated ? (
                                        <Navigate to="/chat" replace />
                                    ) : (
                                        <Navigate to="/login" replace />
                                    )
                                }
                            />

                            <Route path="*" element={<Navigate to="/" replace />} />
                        </Routes>
                    </Suspense>
                </div>
            </Router>
        </ThemeProvider>
    );
}

export default App;

```

`src/App.test.js`

```javascript
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

```

`src/components/AuthPage.js`

```javascript
// client/src/components/AuthPage.js
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { signinUser, signupUser } from '../services/api';

const AuthPage = ({ setIsAuthenticated }) => {
    const [isLogin, setIsLogin] = useState(true);
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const navigate = useNavigate();

    const handleAuth = async (e) => {
        e.preventDefault();
        setError(''); setLoading(true);

        if (!username.trim() || !password.trim()) {
            setError('Username and password cannot be empty.');
            setLoading(false); return;
        }

        try {
            let response;
            const userData = { username, password };
            if (isLogin) {
                response = await signinUser(userData);
            } else {
                 if (password.length < 6) {
                     setError('Password must be at least 6 characters long.');
                     setLoading(false); return;
                 }
                response = await signupUser(userData);
            }

            const { sessionId, username: loggedInUsername, _id: userId } = response.data;

            if (!userId || !sessionId || !loggedInUsername) {
                 throw new Error("Incomplete authentication data received from server.");
            }

            // Store user info in localStorage
            localStorage.setItem('sessionId', sessionId);
            localStorage.setItem('username', loggedInUsername);
            localStorage.setItem('userId', userId); // Store userId

            setIsAuthenticated(true); // Update App state
            navigate('/chat', { replace: true }); // Redirect to chat page

        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || `An error occurred during ${isLogin ? 'sign in' : 'sign up'}.`;
            setError(errorMessage);
            console.error("Auth Error:", err.response || err);
            // Clear potentially invalid items on auth error
            localStorage.removeItem('sessionId');
            localStorage.removeItem('username');
            localStorage.removeItem('userId');
            setIsAuthenticated(false);
        } finally {
            setLoading(false);
        }
    };

    const toggleMode = () => {
        setIsLogin(!isLogin);
        setUsername(''); setPassword(''); setError('');
    };

    return (
        <div className="auth-container">
            <div className="auth-box">
                <h2>{isLogin ? 'Sign In' : 'Sign Up'}</h2>
                <form onSubmit={handleAuth}>
                    <div className="input-group">
                        <label htmlFor="username">Username</label>
                        <input
                            type="text" id="username" value={username}
                            onChange={(e) => setUsername(e.target.value)}
                            required autoComplete="username"
                            disabled={loading}
                        />
                    </div>
                    <div className="input-group">
                        <label htmlFor="password">Password</label>
                        <input
                            type="password" id="password" value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            required autoComplete={isLogin ? "current-password" : "new-password"}
                            disabled={loading}
                        />
                    </div>
                    {error && <p className="error-message">{error}</p>}
                    <button type="submit" disabled={loading} className="auth-button">
                        {loading ? 'Processing...' : (isLogin ? 'Sign In' : 'Sign Up')}
                    </button>
                </form>
                <button onClick={toggleMode} className="toggle-button" disabled={loading}>
                    {isLogin ? 'Need an account? Sign Up' : 'Have an account? Sign In'}
                </button>
            </div>
        </div>
    );
};

// --- CSS for AuthPage (included directly) ---
const AuthPageCSS = `
.auth-container { display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #f0f2f5; }
.auth-box { background: white; padding: 40px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); width: 100%; max-width: 400px; text-align: center; }
.auth-box h2 { margin-bottom: 25px; color: #333; }
.input-group { margin-bottom: 20px; text-align: left; }
.input-group label { display: block; margin-bottom: 8px; color: #555; font-weight: bold; }
.input-group input { width: 100%; padding: 12px 15px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; font-size: 1rem; }
.input-group input:focus { outline: none; border-color: #007bff; box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25); }
.input-group input:disabled { background-color: #e9ecef; cursor: not-allowed; }
.auth-button { width: 100%; padding: 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; font-size: 1rem; cursor: pointer; transition: background-color 0.3s ease; margin-top: 10px; }
.auth-button:hover:not(:disabled) { background-color: #0056b3; }
.auth-button:disabled { background-color: #cccccc; cursor: not-allowed; }
.toggle-button { background: none; border: none; color: #007bff; cursor: pointer; margin-top: 20px; font-size: 0.9rem; }
.toggle-button:hover:not(:disabled) { text-decoration: underline; }
.toggle-button:disabled { color: #999; cursor: not-allowed; }
.error-message { color: #dc3545; margin-top: 15px; margin-bottom: 0; font-size: 0.9rem; }
`;
// --- Inject CSS ---
const styleTagAuthId = 'auth-page-styles';
if (!document.getElementById(styleTagAuthId)) {
    const styleTag = document.createElement("style");
    styleTag.id = styleTagAuthId;
    styleTag.type = "text/css";
    styleTag.innerText = AuthPageCSS;
    document.head.appendChild(styleTag);
}
// --- End CSS Injection ---

export default AuthPage;

```

`src/components/ChatPage.css`

```css
/* client/src/components/ChatPage.css */

/* === Dark Theme Variables === */
:root {
  --bg-main: #121212; /* Very dark grey, almost black */
  --bg-sidebar: #1e1e1e; /* Slightly lighter dark grey */
  --bg-header: #1e1e1e;
  --bg-messages: #121212;
  --bg-input: #2a2a2a; /* Dark grey for inputs */
  --bg-widget: #252526; /* VSCode-like dark grey */

  --text-primary: #e0e0e0; /* Light grey for primary text */
  --text-secondary: #a0a0a0; /* Medium grey for secondary text */
  --text-link: #58a6ff; /* Light blue for links/accents */

  --border-color: #3a3a3a; /* Dark border */
  --scrollbar-thumb: #4a4a50;
  --scrollbar-track: transparent;

  --user-message-bg: #005c9d; /* Darker blue for user messages */
  --user-message-text: #ffffff;
  --model-message-bg: #333333; /* Dark grey for model messages */
  --model-message-text: #e0e0e0;

  --accent-blue: #007acc; /* Standard blue accent */
  --accent-blue-light: #3b9cff;
  --error-color: #f44747;
  --error-bg: rgba(244, 71, 71, 0.1);
  --success-color: #4caf50;
  --success-bg: rgba(76, 175, 80, 0.1);

  --code-bg: #1e1e1e;
  --code-text: #d4d4d4;
  --code-border: #3a3a3a;
}

/* === Global Styles === */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: var(--bg-main);
  color: var(--text-primary);
  height: 100vh;
  overflow: hidden; /* Prevent body scroll */
}

/* === Main Layout === */
.chat-page-container {
  display: flex;
  height: 100vh;
  background-color: var(--bg-main);
}

/* === Sidebar Area === */
.sidebar-area {
  width: 280px; /* Slightly wider */
  flex-shrink: 0;
  background-color: var(--bg-sidebar);
  border-right: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  overflow: hidden; /* Prevent sidebar itself from scrolling */
  height: 100vh; /* Ensure full height */
}

/* Widgets within Sidebar */
.system-prompt-widget,
.file-upload-widget,
.file-manager-widget {
  background-color: var(--bg-widget); /* Use widget background */
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0; /* Prevent shrinking */
}
.system-prompt-widget { padding: 15px; }
.file-upload-widget { padding: 15px; }
.file-manager-widget {
  flex-grow: 1; /* Allow file manager to take remaining space */
  overflow: hidden; /* Contains the scrolling within its list */
  border-bottom: none; /* No border at the very bottom */
  display: flex; /* Ensure flex properties apply */
  flex-direction: column;
}


/* === Chat Container === */
.chat-container {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  background-color: var(--bg-messages);
  overflow: hidden; /* Prevent chat container scroll, manage internally */
  height: 100vh;
}

/* Chat Header */
.chat-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 25px;
  background-color: var(--bg-header);
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0;
}
.chat-header h1 {
  margin: 0;
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--text-primary);
}
.header-controls {
  display: flex;
  align-items: center;
  gap: 12px;
}
.username-display {
  font-size: 0.9rem;
  color: var(--text-secondary);
  white-space: nowrap;
}
.header-button {
  padding: 6px 14px;
  font-size: 0.85rem;
  font-weight: 500;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.2s, color 0.2s, border-color 0.2s;
  background-color: #3a3a40;
  color: var(--text-primary);
  border: 1px solid var(--border-color);
}
.header-button:hover:not(:disabled) {
  background-color: #4a4a50;
  border-color: #5a5a60;
}
.header-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
.logout-button:hover:not(:disabled) {
  background-color: var(--error-bg);
  border-color: var(--error-color);
  color: var(--error-color);
}

/* Messages Area */
.messages-area {
  flex-grow: 1;
  overflow-y: auto; /* Enable scrolling ONLY for messages */
  padding: 25px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  scrollbar-width: thin;
  scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
}
.messages-area::-webkit-scrollbar { width: 8px; }
.messages-area::-webkit-scrollbar-track { background: var(--scrollbar-track); }
.messages-area::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb); border-radius: 4px; }

/* Individual Message Styling */
.message {
  display: flex;
  max-width: 80%; /* Max width of a message bubble */
  position: relative;
  word-wrap: break-word;
  flex-direction: column; /* Stack content and timestamp */
}
.message.user {
  align-self: flex-end;
  align-items: flex-end; /* Align timestamp to the right */
}
.message.model {
  align-self: flex-start;
  align-items: flex-start; /* Align timestamp to the left */
}
.message-content {
  padding: 12px 18px;
  border-radius: 18px;
  font-size: 0.95rem;
  line-height: 1.6;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
  text-align: left; /* Ensure text aligns left within bubble */
}
.message.user .message-content {
  background-color: var(--user-message-bg);
  color: var(--user-message-text);
  border-bottom-right-radius: 5px; /* Speech bubble tail */
}
.message.model .message-content {
  background-color: var(--model-message-bg);
  color: var(--model-message-text);
  border-bottom-left-radius: 5px; /* Speech bubble tail */
}
/* Markdown Styles within messages */
.message-content p { margin: 0 0 0.6em 0; }
.message-content p:last-child { margin-bottom: 0; }
.message-content strong { font-weight: 600; }
.message-content em { font-style: italic; }
.message-content ul, .message-content ol { padding-left: 25px; margin: 0.5em 0; }
.message-content li { margin-bottom: 0.3em; }
.message-content a { color: var(--text-link); text-decoration: none; }
.message-content a:hover { text-decoration: underline; }
.message-content pre {
  background-color: var(--code-bg);
  border: 1px solid var(--code-border);
  border-radius: 6px;
  padding: 12px 15px;
  overflow-x: auto;
  font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
  font-size: 0.9rem;
  margin: 1em 0;
  white-space: pre;
  color: var(--code-text);
  scrollbar-width: thin;
  scrollbar-color: var(--scrollbar-thumb) var(--code-bg);
}
.message-content pre::-webkit-scrollbar { height: 6px; }
.message-content pre::-webkit-scrollbar-track { background: var(--code-bg); }
.message-content pre::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb); border-radius: 3px; }
.message-content code { /* Inline code */
  font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
  font-size: 0.88rem;
  background-color: rgba(255, 255, 255, 0.08);
  padding: 0.2em 0.5em;
  border-radius: 4px;
  border: 1px solid var(--border-color);
  color: var(--text-secondary);
}
.message-content pre code { /* Code within pre block */
  background-color: transparent;
  padding: 0;
  border: none;
  font-size: inherit;
  color: inherit;
}
/* Citation Style */
.message-content em:has(> span.citation-ref) {
   font-style: normal;
   display: block;
   margin-top: 10px;
   font-size: 0.8rem;
   color: var(--text-secondary);
}
.citation-ref {
   /* Add specific styles if needed */
}


.message-timestamp {
  font-size: 0.7rem;
  color: var(--text-secondary);
  margin-top: 6px;
  padding: 0 5px; /* Add slight padding */
}

/* Loading/Error Indicators */
.loading-indicator, .error-indicator {
  text-align: center;
  padding: 10px 20px;
  font-size: 0.85rem;
  font-style: italic;
  color: var(--text-secondary);
  flex-shrink: 0; /* Prevent shrinking */
  margin: 5px 20px; /* Add margin */
}
.error-indicator {
  color: var(--error-color);
  background-color: var(--error-bg);
  border: 1px solid var(--error-color);
  border-radius: 4px;
  font-style: normal;
}
.message-error { /* Style for message rendering errors */
  color: var(--error-color);
  font-style: italic;
  text-align: center;
  padding: 5px;
  font-size: 0.8rem;
}

/* Input Area */
.input-area {
  display: flex;
  align-items: center; /* Align items vertically */
  padding: 12px 20px; /* Reduced padding slightly */
  border-top: 1px solid var(--border-color);
  background-color: var(--bg-header); /* Match header background */
  flex-shrink: 0;
  gap: 10px; /* Space between elements */
}

.input-area textarea {
  flex-grow: 1;
  padding: 10px 18px;
  border: 1px solid var(--border-color);
  border-radius: 20px; /* Pill shape */
  resize: none;
  font-size: 0.95rem;
  line-height: 1.5;
  max-height: 120px; /* Limit height */
  overflow-y: auto; /* Scroll if needed */
  box-sizing: border-box;
  font-family: inherit;
  background-color: var(--bg-input);
  color: var(--text-primary);
  scrollbar-width: thin;
  scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
}
.input-area textarea::-webkit-scrollbar { width: 6px; }
.input-area textarea::-webkit-scrollbar-track { background: var(--scrollbar-track); }
.input-area textarea::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb); border-radius: 3px; }
.input-area textarea::placeholder { color: var(--text-secondary); opacity: 0.7; }
.input-area textarea:focus {
  outline: none;
  border-color: var(--accent-blue);
  background-color: var(--bg-input); /* Keep bg same on focus */
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.3);
}
.input-area textarea:disabled {
  background-color: #2a2a30;
  opacity: 0.6;
  cursor: not-allowed;
}

/* RAG Toggle Styles */
.rag-toggle-container {
  display: flex;
  align-items: center;
  gap: 6px; /* Space between checkbox and label */
  color: var(--text-secondary);
  cursor: pointer;
  padding: 5px 8px;
  border-radius: 4px;
  white-space: nowrap; /* Prevent "RAG" label wrapping */
  flex-shrink: 0; /* Prevent toggle shrinking */
  transition: background-color 0.2s ease;
  user-select: none;
}
.rag-toggle-container:has(input:not(:disabled)):hover {
   background-color: rgba(255, 255, 255, 0.05);
}
.rag-toggle-container input[type="checkbox"] {
  cursor: pointer;
  width: 16px;
  height: 16px;
  accent-color: var(--accent-blue); /* Use theme color for checkmark */
  margin: 0; /* Remove default margins */
  vertical-align: middle; /* Align checkbox better */
}
.rag-toggle-container label {
  font-size: 0.85rem;
  cursor: pointer;
  line-height: 1; /* Ensure label aligns well */
}
/* Styles for disabled state */
.rag-toggle-container input[type="checkbox"]:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}
.rag-toggle-container input[type="checkbox"]:disabled + label {
  cursor: not-allowed;
  opacity: 0.6;
  color: #666; /* Muted color when disabled */
}

/* Send Button */
.input-area button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px;
  width: 40px; /* Fixed size */
  height: 40px; /* Fixed size */
  background-color: var(--accent-blue);
  color: white;
  border: none;
  border-radius: 50%; /* Circle */
  cursor: pointer;
  transition: background-color 0.2s ease;
  flex-shrink: 0;
}
.input-area button:hover:not(:disabled) {
  background-color: var(--accent-blue-light);
}
.input-area button:disabled {
  background-color: #3a3a40; /* Use a dark disabled color */
  cursor: not-allowed;
  opacity: 0.7;
}
.input-area button svg {
  width: 20px;
  height: 20px;
}


/* --- Responsive Adjustments --- */
@media (max-width: 900px) {
    .sidebar-area { display: none; } /* Hide sidebar */
    .chat-container { border-left: none; }
}
@media (max-width: 600px) {
     .chat-header { padding: 10px 15px; }
     .chat-header h1 { font-size: 1.1rem; }
     .header-controls { gap: 8px; }
     .header-button { padding: 5px 10px; font-size: 0.8rem; }
     .username-display { display: none; } /* Hide username on small screens */

     .messages-area { padding: 15px; gap: 15px; }
     .message { max-width: 90%; }
     .message-content { padding: 10px 15px; font-size: 0.9rem; }

     .input-area { padding: 10px 12px; gap: 8px; }
     .input-area textarea { font-size: 0.9rem; padding: 8px 15px; }

     /* Adjust toggle for mobile */
     .rag-toggle-container { padding: 4px 6px; gap: 4px;}
     .rag-toggle-container label { font-size: 0.8rem; }
     .rag-toggle-container input[type="checkbox"] { width: 14px; height: 14px; }

     .input-area button { width: 36px; height: 36px; padding: 6px; }
     .input-area button svg { width: 18px; height: 18px; }

}

```

`src/components/ChatPage.js`

```javascript
// client/src/components/ChatPage.js
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import { sendMessage, saveChatHistory, getUserFiles, queryRagService } from '../services/api';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { v4 as uuidv4 } from 'uuid';

import SystemPromptWidget, { availablePrompts, getPromptTextById } from './SystemPromptWidget';
import HistoryModal from './HistoryModal';
import FileUploadWidget from './FileUploadWidget';
import FileManagerWidget from './FileManagerWidget';

import './ChatPage.css';

const ChatPage = ({ setIsAuthenticated }) => {
    const [messages, setMessages] = useState([]);
    const [inputText, setInputText] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [isRagLoading, setIsRagLoading] = useState(false);
    const [error, setError] = useState('');
    const [sessionId, setSessionId] = useState(''); // Initialize empty, set from localStorage
    const [userId, setUserId] = useState(''); // Initialize empty, set from localStorage
    const [username, setUsername] = useState(''); // Initialize empty, set from localStorage
    const [currentSystemPromptId, setCurrentSystemPromptId] = useState('friendly');
    const [editableSystemPromptText, setEditableSystemPromptText] = useState(() => getPromptTextById('friendly'));
    const [isHistoryModalOpen, setIsHistoryModalOpen] = useState(false);
    const [fileRefreshTrigger, setFileRefreshTrigger] = useState(0);
    const [hasFiles, setHasFiles] = useState(false);
    const [isRagEnabled, setIsRagEnabled] = useState(false);

    const messagesEndRef = useRef(null);
    const navigate = useNavigate();

    // --- Effects ---
    useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }); }, [messages]);

    // Validate auth info on mount
    useEffect(() => {
        const storedSessionId = localStorage.getItem('sessionId');
        const storedUserId = localStorage.getItem('userId');
        const storedUsername = localStorage.getItem('username');

        if (!storedUserId || !storedSessionId || !storedUsername) {
            console.warn("ChatPage Mount: Missing auth info in localStorage. Redirecting to login.");
            handleLogout(true); // Use logout function for cleanup
        } else {
            console.log("ChatPage Mount: Auth info found. Setting state.");
            setSessionId(storedSessionId);
            setUserId(storedUserId);
            setUsername(storedUsername);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []); // Run ONCE on mount

    // Check for user files on mount and refresh, only if userId is set
    useEffect(() => {
        const checkUserFiles = async () => {
            // Ensure userId is available before fetching
            const currentUserId = localStorage.getItem('userId');
            if (!currentUserId) {
                console.log("User files check skipped: No userId available.");
                setHasFiles(false);
                setIsRagEnabled(false);
                return;
            }
            console.log("Checking user files for userId:", currentUserId);
            try {
                const response = await getUserFiles(); // API interceptor adds the header
                const filesExist = response.data && response.data.length > 0;
                setHasFiles(filesExist);
                setIsRagEnabled(filesExist); // Enable RAG by default if files exist
                console.log("User files check successful:", filesExist ? `${response.data.length} files found. RAG default: ${filesExist}` : "No files found. RAG default: false");
            } catch (err) {
                console.error("Error checking user files:", err);
                if (err.response?.status === 401 && !window.location.pathname.includes('/login')) {
                     console.warn("Received 401 checking files, logging out.");
                     handleLogout(true);
                } else {
                    setError("Could not check user files.");
                    setHasFiles(false);
                    setIsRagEnabled(false);
                }
            }
        };

        // Only run if userId is set (from the initial mount effect)
        if (userId) {
            checkUserFiles();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [userId, fileRefreshTrigger]); // Re-check when userId is set or file list might change

    // --- Callback Definitions ---
    const triggerFileRefresh = useCallback(() => setFileRefreshTrigger(prev => prev + 1), []);
    const handlePromptSelectChange = useCallback((newId) => {
        setCurrentSystemPromptId(newId); setEditableSystemPromptText(getPromptTextById(newId));
        setError(prev => prev && (prev.includes("Session invalid") || prev.includes("Critical Error")) ? prev : `Assistant mode changed.`);
        setTimeout(() => { setError(prev => prev === `Assistant mode changed.` ? '' : prev); }, 3000);
    }, []);
    const handlePromptTextChange = useCallback((newText) => {
        setEditableSystemPromptText(newText);
        const matchingPreset = availablePrompts.find(p => p.id !== 'custom' && p.prompt === newText);
        setCurrentSystemPromptId(matchingPreset ? matchingPreset.id : 'custom');
    }, []);
    const handleHistory = useCallback(() => setIsHistoryModalOpen(true), []);
    const closeHistoryModal = useCallback(() => setIsHistoryModalOpen(false), []);

    const saveAndReset = useCallback(async (isLoggingOut = false, onCompleteCallback = null) => {
        const currentSessionId = localStorage.getItem('sessionId'); // Get fresh ID
        const currentUserId = localStorage.getItem('userId'); // Get fresh ID
        const messagesToSave = [...messages];

        if (!currentSessionId || !currentUserId) {
             console.error("Save Error: Session ID or User ID missing.");
             setError("Critical Error: Session info missing.");
             if (onCompleteCallback) onCompleteCallback();
             return;
        }
        if (isLoading || isRagLoading || messagesToSave.length === 0) {
             if (onCompleteCallback) onCompleteCallback();
             return;
        }

        let newSessionId = null;
        setIsLoading(true);
        setError(prev => prev && (prev.includes("Session invalid") || prev.includes("Critical Error")) ? prev : '');

        try {
            console.log(`Saving history for session: ${currentSessionId} (User: ${currentUserId})`);
            // API interceptor will add the x-user-id header
            const response = await saveChatHistory({ sessionId: currentSessionId, messages: messagesToSave });
            newSessionId = response.data.newSessionId;
            if (!newSessionId) throw new Error("Backend failed to provide new session ID.");

            localStorage.setItem('sessionId', newSessionId);
            setSessionId(newSessionId);
            setMessages([]);
            if (!isLoggingOut) {
                handlePromptSelectChange('friendly');
                setError('');
            }
            console.log(`History saved. New session ID: ${newSessionId}`);

        } catch (err) {
            const failErrorMsg = err.response?.data?.message || err.message || 'Failed to save/reset session.';
            console.error("Save/Reset Error:", err.response || err);
            setError(`Session Error: ${failErrorMsg}`);
            if (err.response?.status === 401 && !isLoggingOut) {
                 console.warn("Received 401 saving history, logging out.");
                 handleLogout(true); // Force logout if save fails due to auth
                 // Don't proceed with client-side session generation if auth failed
            } else if (!newSessionId && !isLoggingOut) {
                 newSessionId = uuidv4();
                 localStorage.setItem('sessionId', newSessionId);
                 setSessionId(newSessionId);
                 setMessages([]);
                 handlePromptSelectChange('friendly');
                 console.warn("Save failed, generated new client-side session ID:", newSessionId);
            } else if (isLoggingOut && !newSessionId) {
                 console.error("Save failed during logout.");
            }
        } finally {
            setIsLoading(false);
            if (onCompleteCallback) onCompleteCallback();
        }
    }, [messages, isLoading, isRagLoading, handlePromptSelectChange]); // Removed userId/sessionId state deps, use localStorage directly

    const handleLogout = useCallback((skipSave = false) => {
        const performCleanup = () => {
            console.log("Performing logout cleanup...");
            localStorage.clear(); // Clear everything
            setIsAuthenticated(false);
            setMessages([]); setSessionId(''); setUserId(''); setUsername(''); // Clear state
            setCurrentSystemPromptId('friendly');
            setEditableSystemPromptText(getPromptTextById('friendly')); setError('');
            setHasFiles(false); setIsRagEnabled(false);
            // Ensure navigation happens after state updates
            requestAnimationFrame(() => {
                 if (window.location.pathname !== '/login') {
                     navigate('/login', { replace: true });
                 }
            });
        };
        if (!skipSave && messages.length > 0) {
             saveAndReset(true, performCleanup);
        } else {
             performCleanup();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [navigate, setIsAuthenticated, saveAndReset, messages.length]);

    const handleNewChat = useCallback(() => {
        if (!isLoading && !isRagLoading) {
             saveAndReset(false);
        }
     }, [isLoading, isRagLoading, saveAndReset]);

    const handleSendMessage = useCallback(async (e) => {
        if (e) e.preventDefault();
        const textToSend = inputText.trim();
        const currentSessionId = localStorage.getItem('sessionId'); // Get fresh ID
        const currentUserId = localStorage.getItem('userId'); // Get fresh ID

        if (!textToSend || isLoading || isRagLoading || !currentSessionId || !currentUserId) {
            if (!currentSessionId || !currentUserId) {
                 setError("Session invalid. Please refresh or log in again.");
                 // Optionally trigger logout if auth info is missing
                 if (!currentUserId) handleLogout(true);
            }
            return;
        }

        const newUserMessage = { role: 'user', parts: [{ text: textToSend }], timestamp: new Date() };
        const previousMessages = messages;
        setMessages(prev => [...prev, newUserMessage]);
        setInputText('');
        setError('');

        let relevantDocs = [];
        let ragError = null;

        if (isRagEnabled) {
            setIsRagLoading(true);
            try {
                console.log("RAG Enabled: Querying backend /rag endpoint...");
                // Interceptor adds user ID header
                const ragResponse = await queryRagService({ message: textToSend });
                relevantDocs = ragResponse.data.relevantDocs || [];
                console.log(`RAG Query returned ${relevantDocs.length} documents.`);
            } catch (err) {
                console.error("RAG Query Error:", err.response || err);
                ragError = err.response?.data?.message || "Failed to retrieve documents for RAG.";
                if (err.response?.status === 401) {
                     console.warn("Received 401 during RAG query, logging out.");
                     handleLogout(true);
                     setIsRagLoading(false); // Stop loading before returning
                     return; // Stop processing if auth failed
                }
            } finally {
                setIsRagLoading(false);
            }
        } else {
            console.log("RAG Disabled: Skipping RAG query.");
        }

        setIsLoading(true);
        const historyForAPI = previousMessages;
        const systemPromptToSend = editableSystemPromptText;

        try {
            if (ragError) {
                 setError(prev => prev ? `${prev} | RAG Error: ${ragError}` : `RAG Error: ${ragError}`);
            }

            console.log(`Sending message to backend /message. RAG Enabled: ${isRagEnabled}, Docs Found: ${relevantDocs.length}`);
            // Interceptor adds user ID header
            const sendMessageResponse = await sendMessage({
                message: textToSend,
                history: historyForAPI,
                sessionId: currentSessionId,
                systemPrompt: systemPromptToSend,
                isRagEnabled: isRagEnabled,
                relevantDocs: relevantDocs
            });

            const modelReply = sendMessageResponse.data.reply;
            if (modelReply?.role && modelReply?.parts?.length > 0) {
                setMessages(prev => [...prev, modelReply]);
            } else {
                throw new Error("Invalid reply structure received from backend.");
            }
            setError(prev => prev && (prev.includes("Session invalid") || prev.includes("Critical Error")) ? prev : '');

        } catch (err) {
            const errorMessage = err.response?.data?.message || err.message || 'Failed to get response.';
            setError(prev => prev ? `${prev} | Chat Error: ${errorMessage}` : `Chat Error: ${errorMessage}`);
            console.error("Send Message Error:", err.response || err);
            setMessages(previousMessages); // Rollback UI
            if (err.response?.status === 401 && !window.location.pathname.includes('/login')) {
                 console.warn("Received 401 sending message, logging out.");
                 handleLogout(true);
            }
        } finally {
            setIsLoading(false);
        }
    }, [inputText, isLoading, isRagLoading, messages, editableSystemPromptText, isRagEnabled, handleLogout]); // Removed sessionId/userId state deps

    const handleEnterKey = useCallback((e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleSendMessage();
        }
    }, [handleSendMessage]);

    const handleRagToggle = (event) => {
        setIsRagEnabled(event.target.checked);
    };

    const isProcessing = isLoading || isRagLoading;

    // Render loading or null if userId isn't set yet
    if (!userId) {
        return <div className="loading-indicator"><span>Initializing...</span></div>; // Or some other placeholder
    }

    return (
        <div className="chat-page-container">
            <div className="sidebar-area">
                 <SystemPromptWidget
                    selectedPromptId={currentSystemPromptId} promptText={editableSystemPromptText}
                    onSelectChange={handlePromptSelectChange} onTextChange={handlePromptTextChange}
                 />
                <FileUploadWidget onUploadSuccess={triggerFileRefresh} />
                <FileManagerWidget refreshTrigger={fileRefreshTrigger} />
            </div>

            <div className="chat-container">
                 <header className="chat-header">
                    <h1>Engineering Tutor</h1>
                    <div className="header-controls">
                        <span className="username-display">Hi, {username}!</span>
                        <button onClick={handleHistory} className="header-button history-button" disabled={isProcessing}>History</button>
                        <button onClick={handleNewChat} className="header-button newchat-button" disabled={isProcessing}>New Chat</button>
                        <button onClick={() => handleLogout(false)} className="header-button logout-button" disabled={isProcessing}>Logout</button>
                    </div>
                </header>

                 <div className="messages-area">
                    {messages.map((msg, index) => {
                         if (!msg?.role || !msg?.parts?.length || !msg.timestamp) {
                            console.warn("Rendering invalid message structure at index", index, msg);
                            return <div key={`error-${index}`} className="message-error">Msg Error</div>;
                         }
                         const messageText = msg.parts[0]?.text || '';
                         return (
                            <div key={`${sessionId}-${index}`} className={`message ${msg.role}`}>
                                <div className="message-content">
                                    <ReactMarkdown remarkPlugins={[remarkGfm]}>
                                        {messageText}
                                    </ReactMarkdown>
                                </div>
                                <span className="message-timestamp">
                                    {new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                                </span>
                            </div>
                         );
                    })}
                    <div ref={messagesEndRef} />
                 </div>

                {isProcessing && <div className="loading-indicator"><span>{isRagLoading ? 'Searching documents...' : 'Thinking...'}</span></div>}
                {!isProcessing && error && <div className="error-indicator">{error}</div>}

                <footer className="input-area">
                    <textarea
                        value={inputText} onChange={(e) => setInputText(e.target.value)} onKeyDown={handleEnterKey}
                        placeholder="Ask your tutor..." rows="1" disabled={isProcessing} aria-label="Chat input"
                    />
                    <div className="rag-toggle-container" title={!hasFiles ? "Upload files to enable RAG" : (isRagEnabled ? "Disable RAG (Retrieval-Augmented Generation)" : "Enable RAG (Retrieval-Augmented Generation)")}>
                        <input type="checkbox" id="rag-toggle" checked={isRagEnabled} onChange={handleRagToggle}
                               disabled={!hasFiles || isProcessing} aria-label="Enable RAG" />
                        <label htmlFor="rag-toggle">RAG</label>
                    </div>
                    <button onClick={handleSendMessage} disabled={isProcessing || !inputText.trim()} title="Send Message" aria-label="Send message">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20">
                            <path d="M3.478 2.405a.75.75 0 00-.926.94l2.432 7.905H13.5a.75.75 0 010 1.5H4.984l-2.432 7.905a.75.75 0 00.926.94 60.519 60.519 0 0018.445-8.986.75.75 0 000-1.218A60.517 60.517 0 003.478 2.405z" />
                        </svg>
                    </button>
                </footer>
            </div>

            <HistoryModal isOpen={isHistoryModalOpen} onClose={closeHistoryModal} />

        </div>
    );
};

export default ChatPage;

```

`src/components/FileManagerWidget.js`

```javascript
// client/src/components/FileManagerWidget.js
import React, { useState, useEffect, useCallback } from 'react';
import { getUserFiles, renameUserFile, deleteUserFile } from '../services/api';

const getFileIcon = (type) => {
  switch (type) {
    case 'docs': return '📄';
    case 'images': return '🖼️';
    case 'code': return '💻';
    default: return '📁';
  }
};

const formatFileSize = (bytes) => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  if (typeof bytes !== 'number' || bytes < 0) return 'N/A';
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  const index = Math.max(0, Math.min(i, sizes.length - 1));
  return parseFloat((bytes / Math.pow(k, index)).toFixed(1)) + ' ' + sizes[index];
};


const FileManagerWidget = ({ refreshTrigger }) => {
  const [userFiles, setUserFiles] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [renamingFile, setRenamingFile] = useState(null);
  const [newName, setNewName] = useState('');

  const fetchUserFiles = useCallback(async () => {
    // Ensure userId exists before fetching
    const currentUserId = localStorage.getItem('userId');
    if (!currentUserId) {
        console.log("FileManager: Skipping fetch, no userId.");
        setUserFiles([]); // Clear files if no user
        return;
    }

    setIsLoading(true);
    setError('');
    try {
      // Interceptor adds user ID
      const response = await getUserFiles();
      setUserFiles(response.data || []);
    } catch (err) {
      console.error("Error fetching user files:", err);
      setError(err.response?.data?.message || 'Failed to load files.');
      setUserFiles([]);
      // Handle potential logout if 401
      if (err.response?.status === 401) {
          console.warn("FileManager: Received 401, potential logout needed.");
          // Consider calling a logout function passed via props or context
      }
    } finally {
      setIsLoading(false);
    }
  }, []); // Removed userId dependency, check inside

  useEffect(() => {
    fetchUserFiles();
  }, [refreshTrigger, fetchUserFiles]);

  const handleRenameClick = (file) => {
    setRenamingFile(file.serverFilename);
    setNewName(file.originalName);
    setError('');
  };

  const handleRenameCancel = () => {
    setRenamingFile(null);
    setNewName('');
    setError('');
  };

  const handleRenameSave = async () => {
    if (!renamingFile || !newName.trim()) {
         setError('New name cannot be empty.');
         return;
    }
    if (newName.includes('/') || newName.includes('\\')) {
        setError('New name cannot contain slashes.');
        return;
    }

    setIsLoading(true);
    setError('');
    try {
      // Interceptor adds user ID
      await renameUserFile(renamingFile, newName.trim());
      setRenamingFile(null);
      setNewName('');
      fetchUserFiles();
    } catch (err) {
      console.error("Error renaming file:", err);
      setError(err.response?.data?.message || 'Failed to rename file.');
       if (err.response?.status === 401) {
          console.warn("FileManager: Received 401 during rename.");
      }
    } finally {
       setIsLoading(false);
    }
  };

  const handleRenameInputKeyDown = (e) => {
      if (e.key === 'Enter') {
          handleRenameSave();
      } else if (e.key === 'Escape') {
          handleRenameCancel();
      }
  };

  const handleDeleteFile = async (serverFilename, originalName) => {
    if (!window.confirm(`Are you sure you want to delete "${originalName}"? This cannot be undone.`)) {
      return;
    }

    setIsLoading(true);
    setError('');
    try {
      // Interceptor adds user ID
      await deleteUserFile(serverFilename);
      fetchUserFiles();
    } catch (err) {
      console.error("Error deleting file:", err);
      setError(err.response?.data?.message || 'Failed to delete file.');
       if (err.response?.status === 401) {
          console.warn("FileManager: Received 401 during delete.");
      }
    } finally {
       setIsLoading(false);
    }
  };

  return (
    <div className="file-manager-widget">
      <div className="fm-header">
        <h4>Your Uploaded Files</h4>
        <button
            onClick={fetchUserFiles}
            disabled={isLoading}
            className="fm-refresh-btn"
            title="Refresh File List"
        >
            🔄
        </button>
      </div>

      {error && <div className="fm-error">{error}</div>}

      <div className="fm-file-list-container">
        {isLoading && userFiles.length === 0 ? (
          <p className="fm-loading">Loading files...</p>
        ) : userFiles.length === 0 && !isLoading ? (
          <p className="fm-empty">No files uploaded yet.</p>
        ) : (
          <ul className="fm-file-list">
            {userFiles.map((file) => (
              <li key={file.serverFilename} className="fm-file-item">
                <span className="fm-file-icon">{getFileIcon(file.type)}</span>
                <div className="fm-file-details">
                  {renamingFile === file.serverFilename ? (
                    <div className="fm-rename-section">
                      <input
                        type="text"
                        value={newName}
                        onChange={(e) => setNewName(e.target.value)}
                        onKeyDown={handleRenameInputKeyDown}
                        autoFocus
                        className="fm-rename-input"
                        aria-label={`New name for ${file.originalName}`}
                      />
                      <button onClick={handleRenameSave} disabled={isLoading || !newName.trim()} className="fm-action-btn fm-save-btn" title="Save Name">✔️</button>
                      <button onClick={handleRenameCancel} disabled={isLoading} className="fm-action-btn fm-cancel-btn" title="Cancel Rename">❌</button>
                    </div>
                  ) : (
                    <>
                      <span className="fm-file-name" title={file.originalName}>{file.originalName}</span>
                      <span className="fm-file-size">{formatFileSize(file.size)}</span>
                    </>
                  )}
                </div>
                {renamingFile !== file.serverFilename && (
                  <div className="fm-file-actions">
                    <button
                        onClick={() => handleRenameClick(file)}
                        disabled={isLoading || !!renamingFile}
                        className="fm-action-btn fm-rename-btn"
                        title="Rename"
                    >
                       ✏️
                    </button>
                    <button
                        onClick={() => handleDeleteFile(file.serverFilename, file.originalName)}
                        disabled={isLoading || !!renamingFile}
                        className="fm-action-btn fm-delete-btn"
                        title="Delete"
                    >
                        🗑️
                    </button>
                  </div>
                )}
              </li>
            ))}
          </ul>
        )}
         {isLoading && userFiles.length > 0 && <p className="fm-loading fm-loading-bottom">Processing...</p>}
      </div>
    </div>
  );
};

// --- CSS for FileManagerWidget ---
const FileManagerWidgetCSS = `
/* client/src/components/FileManagerWidget.css */
.file-manager-widget { display: flex; flex-direction: column; gap: 10px; padding: 15px 0px 15px 20px; box-sizing: border-box; height: 100%; overflow: hidden; }
.fm-header { display: flex; justify-content: space-between; align-items: center; padding-right: 20px; flex-shrink: 0; }
.file-manager-widget h4 { margin: 0; color: var(--text-primary); font-size: 0.95rem; font-weight: 600; }
.fm-refresh-btn { background: none; border: 1px solid var(--border-color); color: var(--text-secondary); padding: 3px 6px; border-radius: 4px; cursor: pointer; font-size: 0.9rem; line-height: 1; transition: color 0.2s, border-color 0.2s, background-color 0.2s; }
.fm-refresh-btn:hover:not(:disabled) { color: var(--text-primary); border-color: #555; background-color: #3a3a40; }
.fm-refresh-btn:disabled { cursor: not-allowed; opacity: 0.5; }
.fm-error, .fm-loading, .fm-empty { font-size: 0.85rem; padding: 10px 15px; border-radius: 4px; text-align: center; margin: 5px 20px 5px 0; flex-shrink: 0; }
.fm-error { color: var(--error-color); border: 1px solid var(--error-color); background-color: var(--error-bg); }
.fm-loading, .fm-empty { color: var(--text-secondary); font-style: italic; }
.fm-loading-bottom { margin-top: auto; padding: 5px; }
.fm-file-list-container { flex-grow: 1; overflow-y: auto; padding-right: 10px; margin-right: 10px; position: relative; }
.fm-file-list-container::-webkit-scrollbar { width: 8px; }
.fm-file-list-container::-webkit-scrollbar-track { background: transparent; }
.fm-file-list-container::-webkit-scrollbar-thumb { background-color: #4a4a50; border-radius: 10px; }
.fm-file-list-container { scrollbar-width: thin; scrollbar-color: #4a4a50 transparent; }
.fm-file-list { list-style: none; padding: 0; margin: 0; }
.fm-file-item { display: flex; align-items: center; padding: 8px 5px; margin-bottom: 5px; border-radius: 4px; background-color: #2f2f34; transition: background-color 0.2s ease; gap: 10px; }
.fm-file-item:hover { background-color: #3a3a40; }
.fm-file-icon { flex-shrink: 0; font-size: 1.1rem; line-height: 1; }
.fm-file-details { flex-grow: 1; overflow: hidden; display: flex; flex-direction: column; justify-content: center; min-height: 30px; }
.fm-file-name { font-size: 0.85rem; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.fm-file-size { font-size: 0.7rem; color: var(--text-secondary); margin-top: 2px; }
.fm-file-actions { display: flex; gap: 5px; flex-shrink: 0; margin-left: auto; }
.fm-action-btn { background: none; border: none; color: var(--text-secondary); cursor: pointer; padding: 3px; font-size: 1rem; line-height: 1; border-radius: 3px; transition: color 0.2s ease, background-color 0.2s ease; }
.fm-action-btn:hover:not(:disabled) { color: var(--text-primary); background-color: #4a4a50; }
.fm-action-btn:disabled { opacity: 0.5; cursor: not-allowed; }
.fm-delete-btn:hover:not(:disabled) { color: var(--error-color); }
.fm-rename-btn:hover:not(:disabled) { color: var(--accent-blue-light); }
.fm-save-btn:hover:not(:disabled) { color: #52c41a; } /* Green */
.fm-cancel-btn:hover:not(:disabled) { color: #ffc107; } /* Orange/Yellow */
.fm-rename-section { display: flex; align-items: center; gap: 5px; width: 100%; }
.fm-rename-input { flex-grow: 1; padding: 4px 8px; background-color: var(--bg-input); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.85rem; outline: none; min-width: 50px; }
.fm-rename-input:focus { border-color: var(--accent-blue); }
`;
// --- Inject CSS ---
const styleTagFileManagerId = 'file-manager-widget-styles';
if (!document.getElementById(styleTagFileManagerId)) {
    const styleTag = document.createElement("style");
    styleTag.id = styleTagFileManagerId;
    styleTag.type = "text/css";
    styleTag.innerText = FileManagerWidgetCSS;
    document.head.appendChild(styleTag);
}
// --- End CSS Injection ---

export default FileManagerWidget;

```

`src/components/FileUploadWidget.js`

```javascript
// client/src/components/FileUploadWidget.js
import React, { useState, useRef } from 'react';
import { uploadFile } from '../services/api';

const FileUploadWidget = ({ onUploadSuccess }) => {
  const [selectedFile, setSelectedFile] = useState(null);
  const [uploadStatus, setUploadStatus] = useState(''); // 'uploading', 'success', 'error', ''
  const [statusMessage, setStatusMessage] = useState('');
  const fileInputRef = useRef(null);

  const allowedFileTypesString = ".pdf,.txt,.docx,.doc,.pptx,.ppt,.py,.js,.bmp,.png,.jpg,.jpeg";

  const handleFileChange = (event) => {
    const file = event.target.files[0];
    if (file) {
      const fileExt = "." + file.name.split('.').pop().toLowerCase();
      if (!allowedFileTypesString.includes(fileExt)) {
           setStatusMessage(`Error: File type (${fileExt}) not allowed.`);
           setUploadStatus('error');
           setSelectedFile(null);
           if (fileInputRef.current) fileInputRef.current.value = '';
           return;
      }

      const MAX_SIZE_MB = 20;
      const MAX_SIZE_BYTES = MAX_SIZE_MB * 1024 * 1024;
      if (file.size > MAX_SIZE_BYTES) {
          setStatusMessage(`Error: File exceeds ${MAX_SIZE_MB}MB limit.`);
          setUploadStatus('error');
          setSelectedFile(null);
          if (fileInputRef.current) fileInputRef.current.value = '';
          return;
      }

      setSelectedFile(file);
      setStatusMessage(`Selected: ${file.name}`);
      setUploadStatus('');

    } else {
        // Handle user cancelling file selection if needed
    }
  };

  const handleUpload = async () => {
    if (!selectedFile) {
      setStatusMessage('Please select a file first.');
      setUploadStatus('error');
      return;
    }
    // Ensure userId exists before uploading
     const currentUserId = localStorage.getItem('userId');
     if (!currentUserId) {
         setStatusMessage('Error: Not logged in. Cannot upload file.');
         setUploadStatus('error');
         return;
     }

    setUploadStatus('uploading');
    setStatusMessage(`Uploading ${selectedFile.name}...`);

    const formData = new FormData();
    formData.append('file', selectedFile);

    try {
      // Interceptor adds user ID header
      const response = await uploadFile(formData);

      setUploadStatus('success');
      setStatusMessage(response.data.message || 'Upload successful!');
      console.log('Upload successful:', response.data);

      setSelectedFile(null);
      if (fileInputRef.current) {
          fileInputRef.current.value = '';
      }

      if (onUploadSuccess && typeof onUploadSuccess === 'function') {
          onUploadSuccess();
      }

      setTimeout(() => {
          // Check if status is still success before clearing
          setUploadStatus(prevStatus => prevStatus === 'success' ? '' : prevStatus);
          setStatusMessage(prevMsg => prevMsg === (response.data.message || 'Upload successful!') ? '' : prevMsg);
      }, 4000);


    } catch (err) {
      console.error("Upload Error:", err.response || err);
      setUploadStatus('error');
      setStatusMessage(err.response?.data?.message || 'Upload failed. Please check the file or try again.');
      if (err.response?.status === 401) {
          console.warn("FileUpload: Received 401 during upload.");
          // Consider calling a logout function passed via props or context
      }
    }
  };

  const triggerFileInput = () => {
    fileInputRef.current?.click();
  };

  return (
    <div className="file-upload-widget">
      <h4>Upload File</h4>
      <input
        type="file"
        ref={fileInputRef}
        onChange={handleFileChange}
        accept={allowedFileTypesString}
        style={{ display: 'none' }}
        aria-hidden="true"
      />
      <button
        type="button"
        className="select-file-btn"
        onClick={triggerFileInput}
        disabled={uploadStatus === 'uploading'}
      >
        Choose File
      </button>
      <div className={`status-message ${uploadStatus}`}>
        {statusMessage || 'No file selected.'}
      </div>
      <button
        type="button"
        className="upload-btn"
        onClick={handleUpload}
        disabled={!selectedFile || uploadStatus === 'uploading'}
      >
        {uploadStatus === 'uploading' ? 'Uploading...' : 'Upload'}
      </button>
    </div>
  );
};

// --- CSS for FileUploadWidget ---
const FileUploadWidgetCSS = `
/* client/src/components/FileUploadWidget.css */
.file-upload-widget { display: flex; flex-direction: column; gap: 12px; padding: 20px; box-sizing: border-box; }
.file-upload-widget h4 { margin-top: 0; margin-bottom: 10px; color: var(--text-primary); font-size: 0.95rem; font-weight: 600; }
.select-file-btn, .upload-btn { width: 100%; padding: 9px 15px; border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, opacity 0.2s ease; background-color: #2a2a30; color: var(--text-primary); text-align: center; box-sizing: border-box; }
.select-file-btn:hover:not(:disabled), .upload-btn:hover:not(:disabled) { background-color: #3a3a40; border-color: #4a4a50; }
.select-file-btn:disabled, .upload-btn:disabled { opacity: 0.6; cursor: not-allowed; }
.upload-btn { background-color: var(--accent-blue); border-color: var(--accent-blue); color: var(--user-message-text); }
.upload-btn:hover:not(:disabled) { background-color: var(--accent-blue-light); border-color: var(--accent-blue-light); }
.upload-btn:disabled { background-color: #3a3a40; border-color: var(--border-color); color: var(--text-secondary); opacity: 0.7; }
.status-message { font-size: 0.8rem; color: var(--text-secondary); padding: 8px 10px; background-color: var(--bg-input); border: 1px solid var(--border-color); border-radius: 4px; text-align: center; min-height: 1.6em; line-height: 1.4; word-break: break-word; transition: color 0.2s ease, border-color 0.2s ease, background-color 0.2s ease; }
.status-message.uploading { color: var(--accent-blue-light); border-color: var(--accent-blue); }
.status-message.success { color: #52c41a; border-color: #52c41a; background-color: rgba(82, 196, 26, 0.1); }
.status-message.error { color: var(--error-color); border-color: var(--error-color); background-color: var(--error-bg); }
`;
// --- Inject CSS ---
const styleTagUploadId = 'file-upload-widget-styles';
if (!document.getElementById(styleTagUploadId)) {
    const styleTag = document.createElement("style");
    styleTag.id = styleTagUploadId;
    styleTag.type = "text/css";
    styleTag.innerText = FileUploadWidgetCSS;
    document.head.appendChild(styleTag);
}
// --- End CSS Injection ---

export default FileUploadWidget;

```

`src/components/HistoryModal.js`

```javascript
// client/src/components/HistoryModal.js
import React, { useState, useEffect } from 'react';
import ReactMarkdown from 'react-markdown';
import { getChatSessions, getSessionDetails } from '../services/api';

const HistoryModal = ({ isOpen, onClose }) => {
  const [sessions, setSessions] = useState([]);
  const [selectedSession, setSelectedSession] = useState(null);
  const [isLoadingSessions, setIsLoadingSessions] = useState(false);
  const [isLoadingDetails, setIsLoadingDetails] = useState(false);
  const [error, setError] = useState('');

  useEffect(() => {
    if (isOpen) {
      const fetchSessions = async () => {
        // Ensure userId exists before fetching
        const currentUserId = localStorage.getItem('userId');
        if (!currentUserId) {
            setError('Cannot load history: User not logged in.');
            setSessions([]);
            return;
        }

        setIsLoadingSessions(true);
        setError('');
        setSelectedSession(null);
        setSessions([]);
        try {
          // Interceptor adds user ID
          const response = await getChatSessions();
          setSessions(response.data || []);
        } catch (err) {
          console.error("Error fetching sessions:", err);
          setError(err.response?.data?.message || 'Failed to load chat history sessions.');
          setSessions([]);
          if (err.response?.status === 401) {
              console.warn("HistoryModal: Received 401 fetching sessions.");
              // Optionally close modal or trigger logout
              onClose();
          }
        } finally {
          setIsLoadingSessions(false);
        }
      };
      fetchSessions();
    } else {
      setSessions([]);
      setSelectedSession(null);
      setError('');
      setIsLoadingSessions(false);
      setIsLoadingDetails(false);
    }
  }, [isOpen, onClose]); // Added onClose to dependency array

  const handleSelectSession = async (sessionId) => {
     // Ensure userId exists before fetching
    const currentUserId = localStorage.getItem('userId');
    if (!currentUserId) {
        setError('Cannot load session details: User not logged in.');
        return;
    }
    if (!sessionId || isLoadingDetails || selectedSession?.sessionId === sessionId) return;

    setIsLoadingDetails(true);
    setError('');
    try {
      // Interceptor adds user ID
      const response = await getSessionDetails(sessionId);
      setSelectedSession(response.data);
    } catch (err) {
      console.error(`Error fetching session ${sessionId}:`, err);
      setError(err.response?.data?.message || `Failed to load details for session ${sessionId}.`);
      setSelectedSession(null);
      if (err.response?.status === 401) {
          console.warn("HistoryModal: Received 401 fetching session details.");
          // Optionally close modal or trigger logout
          onClose();
      }
    } finally {
      setIsLoadingDetails(false);
    }
  };

  const formatDate = (dateString) => {
    if (!dateString) return 'N/A';
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime())) {
          throw new Error("Invalid date string");
      }
      return date.toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
    } catch (e) {
      console.warn("Error formatting date:", dateString, e);
      return dateString;
    }
  };

  if (!isOpen) return null;

  return (
    <div className="history-modal-overlay" onClick={onClose}>
      <div className="history-modal-content" onClick={(e) => e.stopPropagation()}>
        <button className="history-modal-close-btn" onClick={onClose} aria-label="Close history">×</button>
        <h2>Chat History</h2>

        {error && !isLoadingDetails && !isLoadingSessions && <div className="history-error">{error}</div>}

        <div className="history-layout">
          <div className="history-session-list">
            <h3>Sessions</h3>
            {isLoadingSessions ? (
              <p className="history-loading">Loading sessions...</p>
            ) : sessions.length === 0 && !error ? (
              <p className="history-empty">No past sessions found.</p>
            ) : (
              <ul>
                {sessions.map((session) => (
                  <li
                    key={session.sessionId}
                    className={selectedSession?.sessionId === session.sessionId ? 'active' : ''}
                    onClick={() => handleSelectSession(session.sessionId)}
                    tabIndex={0}
                    onKeyDown={(e) => (e.key === 'Enter' || e.key === ' ') && handleSelectSession(session.sessionId)}
                    role="button"
                  >
                    <div className="session-preview" title={session.preview || 'Chat session'}>
                      {session.preview || 'Chat session'}
                    </div>
                    <div className="session-date">
                      {formatDate(session.updatedAt || session.createdAt)} ({session.messageCount || 0} msgs)
                    </div>
                  </li>
                ))}
              </ul>
            )}
          </div>

          <div className="history-session-details">
            <h3>Session Details</h3>
            {isLoadingDetails ? (
              <p className="history-loading">Loading details...</p>
            ) : !selectedSession ? (
              <p className="history-empty">Select a session from the left to view its messages.</p>
            ) : (
              <div className="history-messages-area">
                {selectedSession.messages && selectedSession.messages.length > 0 ? (
                  selectedSession.messages.map((msg, index) => (
                    !msg?.role || !msg?.parts?.length ?
                      <div key={`${selectedSession.sessionId}-err-${index}`} className="history-message-error">Invalid message data</div>
                    :
                    <div key={`${selectedSession.sessionId}-${index}`} className={`history-message ${msg.role}`}>
                      <div className="history-message-content">
                        <ReactMarkdown children={msg.parts[0]?.text || ''} />
                      </div>
                      <span className="history-message-timestamp">
                        {formatDate(msg.timestamp)}
                      </span>
                    </div>
                  ))
                ) : (
                  <p className="history-empty">This session appears to have no messages.</p>
                )}
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};


// --- CSS for HistoryModal ---
const HistoryModalCSS = `
/* client/src/components/HistoryModal.css */
.history-modal-overlay { position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.75); display: flex; justify-content: center; align-items: center; z-index: 1000; backdrop-filter: blur(4px); padding: 20px; box-sizing: border-box; }
.history-modal-content { background-color: var(--bg-header); color: var(--text-primary); padding: 20px 25px; border-radius: 10px; width: 90%; max-width: 1200px; height: 85vh; max-height: 800px; box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5); position: relative; display: flex; flex-direction: column; overflow: hidden; }
.history-modal-close-btn { position: absolute; top: 10px; right: 10px; background: transparent; border: none; font-size: 2.2rem; font-weight: bold; color: var(--text-secondary); cursor: pointer; line-height: 1; padding: 5px; transition: color 0.2s ease; }
.history-modal-close-btn:hover { color: var(--text-primary); }
.history-modal-content h2 { margin: 0 0 15px 0; padding-bottom: 10px; text-align: center; font-weight: 600; color: var(--text-primary); border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
.history-error, .history-loading, .history-empty { color: var(--text-secondary); padding: 12px 15px; border-radius: 6px; margin-bottom: 15px; text-align: center; font-size: 0.9rem; font-style: italic; }
.history-error { color: var(--error-color); background-color: var(--error-bg); border: 1px solid var(--error-color); font-style: normal; }
.history-layout { display: flex; flex-grow: 1; gap: 20px; overflow: hidden; }
.history-session-list { width: 320px; flex-shrink: 0; display: flex; flex-direction: column; overflow-y: auto; padding-right: 10px; border-right: 1px solid var(--border-color); }
.history-session-list h3 { margin: 0 0 12px 0; padding: 0 5px; font-size: 1rem; font-weight: 600; color: var(--text-secondary); flex-shrink: 0; }
.history-session-list ul { list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto; }
.history-session-list li { padding: 10px 12px; margin-bottom: 8px; border: 1px solid transparent; border-radius: 6px; cursor: pointer; transition: background-color 0.15s ease, border-color 0.15s ease; background-color: #2f2f34; }
.history-session-list li:hover { background-color: #3a3a40; border-color: #4a4a50; }
.history-session-list li.active { background-color: var(--accent-blue); border-color: var(--accent-blue); color: var(--user-message-text); }
.history-session-list li.active .session-date { color: rgba(255, 255, 255, 0.85); }
.session-preview { font-size: 0.9rem; font-weight: 500; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.session-date { font-size: 0.75rem; color: var(--text-secondary); }
.history-session-details { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; background-color: var(--bg-messages); border-radius: 8px; }
.history-session-details h3 { margin: 0; padding: 12px 20px; font-size: 1rem; font-weight: 600; color: var(--text-secondary); border-bottom: 1px solid var(--border-color); background-color: var(--bg-header); border-top-left-radius: 8px; border-top-right-radius: 8px; flex-shrink: 0; }
.history-session-details > .history-empty, .history-session-details > .history-loading { padding: 30px; text-align: center; flex-grow: 1; display: flex; align-items: center; justify-content: center; }
.history-messages-area { flex-grow: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 18px; }
.history-message { display: flex; max-width: 85%; position: relative; word-wrap: break-word; flex-direction: column; }
.history-message.user { align-self: flex-end; align-items: flex-end; }
.history-message.model { align-self: flex-start; align-items: flex-start; }
.history-message-content { padding: 10px 15px; border-radius: 16px; font-size: 0.9rem; line-height: 1.6; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); text-align: left; }
.history-message.user .history-message-content { background-color: var(--user-message-bg); color: var(--user-message-text); border-bottom-right-radius: 5px; }
.history-message.model .history-message-content { background-color: var(--model-message-bg); color: var(--model-message-text); border-bottom-left-radius: 5px; }
.history-message-content p { margin: 0 0 0.5em 0; }
.history-message-content p:last-child { margin-bottom: 0; }
.history-message-content pre { background-color: var(--code-bg); border: 1px solid var(--code-border); border-radius: 6px; padding: 12px; overflow-x: auto; font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.88rem; margin: 0.8em 0; white-space: pre; color: var(--code-text); }
.history-message-content code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.88rem; background-color: rgba(255, 255, 255, 0.08); padding: 0.2em 0.4em; border-radius: 4px; border: 1px solid var(--border-color); color: var(--text-secondary); }
.history-message-content pre code { background-color: transparent; padding: 0; border: none; font-size: inherit; color: inherit; }
.history-message-timestamp { font-size: 0.7rem; color: var(--text-secondary); margin-top: 5px; }
.history-message-error { color: var(--error-color); font-style: italic; padding: 5px 0; text-align: center; font-size: 0.8rem; }
.history-session-list::-webkit-scrollbar, .history-session-list ul::-webkit-scrollbar, .history-messages-area::-webkit-scrollbar { width: 8px; }
.history-session-list::-webkit-scrollbar-track, .history-session-list ul::-webkit-scrollbar-track, .history-messages-area::-webkit-scrollbar-track { background: transparent; }
.history-session-list::-webkit-scrollbar-thumb, .history-session-list ul::-webkit-scrollbar-thumb, .history-messages-area::-webkit-scrollbar-thumb { background-color: #4a4a50; border-radius: 10px; }
.history-session-list, .history-session-list ul, .history-messages-area { scrollbar-width: thin; scrollbar-color: #4a4a50 transparent; }
`;
// --- Inject CSS ---
const styleTagHistoryId = 'history-modal-styles';
if (!document.getElementById(styleTagHistoryId)) {
    const styleTag = document.createElement("style");
    styleTag.id = styleTagHistoryId;
    styleTag.type = "text/css";
    styleTag.innerText = HistoryModalCSS;
    document.head.appendChild(styleTag);
}
// --- End CSS Injection ---

export default HistoryModal;

```

`src/components/SystemPromptWidget.js`

```javascript
// client/src/components/SystemPromptWidget.js
import React from 'react';
// Removed CSS import

// Define the THREE required system prompts + a Custom option
export const availablePrompts = [
  {
    id: 'friendly',
    title: 'Friendly Tutor',
    prompt: 'You are a friendly, patient, and encouraging tutor specializing in engineering and scientific topics for PhD students. Explain concepts clearly, break down complex ideas, use analogies, and offer positive reinforcement. Ask follow-up questions to ensure understanding.',
  },
  {
    id: 'explorer', // Changed ID slightly for clarity
    title: 'Concept Explorer',
    prompt: 'You are an expert academic lecturer introducing a new, complex engineering or scientific concept. Your goal is to provide a deep, structured explanation. Define terms rigorously, outline the theory, provide relevant mathematical formulations (using Markdown), illustrative examples, and discuss applications or limitations pertinent to PhD-level research.',
  },
  {
    id: 'knowledge_check',
    title: 'Knowledge Check',
    prompt: 'You are assessing understanding of engineering/scientific topics. Ask targeted questions to test knowledge, identify misconceptions, and provide feedback on the answers. Start by asking the user what topic they want to be quizzed on.',
  },
   {
    id: 'custom', // Represents user-edited state
    title: 'Custom Prompt',
    prompt: '', // Placeholder, actual text comes from textarea
  },
];

// Helper to find prompt text by ID - Export if needed elsewhere
export const getPromptTextById = (id) => {
  const prompt = availablePrompts.find(p => p.id === id);
  return prompt ? prompt.prompt : ''; // Return empty string if not found
};


/**
 * Renders a sidebar widget with a dropdown for preset prompts
 * and an editable textarea for the current system prompt.
 * @param {object} props - Component props.
 * @param {string} props.selectedPromptId - The ID of the currently active preset (or 'custom').
 * @param {string} props.promptText - The current text of the system prompt (potentially edited).
 * @param {function} props.onSelectChange - Callback when dropdown selection changes. Passes the new ID.
 * @param {function} props.onTextChange - Callback when the textarea content changes. Passes the new text.
 */
const SystemPromptWidget = ({ selectedPromptId, promptText, onSelectChange, onTextChange }) => {

  const handleDropdownChange = (event) => {
    const newId = event.target.value;
    onSelectChange(newId); // Notify parent of the ID change
  };

  const handleTextareaChange = (event) => {
    onTextChange(event.target.value); // Notify parent of the text change
  };

  return (
    <div className="system-prompt-widget">
      <h3>Assistant Mode</h3>

      {/* Dropdown for selecting presets */}
      <select
        className="prompt-select"
        value={selectedPromptId} // Control the selected option via state
        onChange={handleDropdownChange}
        aria-label="Select Assistant Mode"
      >
        {/* Filter out 'custom' from being a selectable option initially */}
        {availablePrompts.filter(p => p.id !== 'custom').map((p) => (
          <option key={p.id} value={p.id}>
            {p.title}
          </option>
        ))}
        {/* Add Custom option dynamically if the current ID is 'custom' */}
        {/* This ensures "Custom Prompt" appears in the dropdown only when it's actually active */}
        {selectedPromptId === 'custom' && (
            <option key="custom" value="custom">
                Custom Prompt
            </option>
        )}
      </select>

      {/* Editable Textarea for the actual prompt */}
      <label htmlFor="system-prompt-text" className="prompt-label">
        System Prompt (Editable)
      </label>
      <textarea
        id="system-prompt-text"
        className="prompt-textarea"
        value={promptText} // Display the current prompt text (could be preset or edited)
        onChange={handleTextareaChange}
        rows="5" // Suggests initial height, CSS controls actual fixed height
        maxLength="2000" // Optional: Limit character count if desired
        placeholder="The current system prompt will appear here. You can edit it directly."
        aria-label="Editable System Prompt Text"
      />
       {/* Optional: Character count indicator
       <div className="char-count">{promptText?.length || 0} / 2000</div> */}
    </div>
  );
};

// --- CSS for SystemPromptWidget ---
const SystemPromptWidgetCSS = `
/* client/src/components/SystemPromptWidget.css */
.system-prompt-widget { padding: 20px; background-color: var(--bg-header); box-sizing: border-box; display: flex; flex-direction: column; flex-shrink: 0; }
.system-prompt-widget h3 { margin-top: 0; margin-bottom: 15px; color: var(--text-primary); font-size: 1rem; font-weight: 600; padding-bottom: 10px; }
.prompt-select { width: 100%; padding: 10px 12px; margin-bottom: 15px; background-color: #2a2a30; color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; font-size: 0.9rem; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url('data:image/svg+xml;utf8,<svg fill="%23b0b3b8" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>'); background-repeat: no-repeat; background-position: right 10px center; background-size: 18px; }
.prompt-select:focus { outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 2px rgba(0, 132, 255, 0.3); }
.prompt-label { display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.85rem; font-weight: 500; }
.prompt-textarea { width: 100%; background-color: var(--bg-input); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px 12px; font-size: 0.85rem; line-height: 1.5; box-sizing: border-box; font-family: inherit; resize: none; height: 100px; overflow-y: auto; }
.prompt-textarea:focus { outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 2px rgba(0, 132, 255, 0.3); }
.prompt-textarea::placeholder { color: var(--text-secondary); opacity: 0.7; }
.char-count { text-align: right; font-size: 0.75rem; color: var(--text-secondary); margin-top: 5px; }
`;
// --- Inject CSS ---
const styleTagPromptId = 'system-prompt-widget-styles';
if (!document.getElementById(styleTagPromptId)) {
    const styleTag = document.createElement("style");
    styleTag.id = styleTagPromptId;
    styleTag.type = "text/css";
    styleTag.innerText = SystemPromptWidgetCSS;
    document.head.appendChild(styleTag);
}
// --- End CSS Injection ---


export default SystemPromptWidget;

```

`src/index.css`

```css
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

```

`src/index.js`

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

```

`src/reportWebVitals.js`

```javascript
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

```

`src/services/api.js`

```javascript
// client/src/services/api.js
import axios from 'axios';

// Dynamically determine API Base URL
const getApiBaseUrl = () => {
    // Use REACT_APP_BACKEND_PORT environment variable if set during build, otherwise default
    // This allows overriding the port via build environment if needed.
    const backendPort = process.env.REACT_APP_BACKEND_PORT || 5001;
    const hostname = window.location.hostname; // Get hostname browser is accessing

    // Use http protocol by default for local development
    const protocol = window.location.protocol === 'https:' ? 'https:' : 'http:';

    // If hostname is localhost or 127.0.0.1, construct URL with localhost
    // Otherwise, use the hostname the frontend was accessed with (e.g., LAN IP)
    const backendHost = (hostname === 'localhost' || hostname === '127.0.0.1')
        ? 'localhost'
        : hostname;

    return `${protocol}//${backendHost}:${backendPort}/api`;
};

const API_BASE_URL = getApiBaseUrl();
console.log("API Base URL:", API_BASE_URL); // Log the dynamically determined URL

// Create Axios instance
const api = axios.create({
    baseURL: API_BASE_URL,
});

// --- Interceptor to add User ID header (TEMP AUTH) ---
api.interceptors.request.use(
    (config) => {
        const userId = localStorage.getItem('userId');
        // Add header only if userId exists
        if (userId) {
            config.headers['x-user-id'] = userId;
        } else if (!config.url.includes('/auth/')) {
             // Only warn if it's NOT an authentication request
             console.warn("API Interceptor: userId not found in localStorage for non-auth request to", config.url);
             // Consider rejecting the request if userId is absolutely mandatory for the endpoint
             // return Promise.reject(new Error("User ID not found. Please log in."));
        }

        // Handle FormData content type specifically
        if (config.data instanceof FormData) {
            // Let Axios set the correct 'multipart/form-data' header with boundary
            // Deleting it ensures Axios handles it automatically.
            delete config.headers['Content-Type'];
        } else if (!config.headers['Content-Type']) {
             // Set default Content-Type for other requests (like JSON) if not already set
             config.headers['Content-Type'] = 'application/json';
        }
        // console.log("API Request Config:", config); // Debug: Log outgoing request config
        return config;
    },
    (error) => {
        console.error("API Request Interceptor Error:", error);
        return Promise.reject(error);
    }
);

// --- Interceptor to handle 401 Unauthorized responses ---
api.interceptors.response.use(
    (response) => {
        // Any status code within the range of 2xx cause this function to trigger
        return response;
    },
    (error) => {
        // Any status codes outside the range of 2xx cause this function to trigger
        if (error.response && error.response.status === 401) {
            console.warn("API Response Interceptor: Received 401 Unauthorized. Clearing auth data and redirecting to login.");
            // Clear potentially invalid auth tokens/user info
            localStorage.removeItem('sessionId');
            localStorage.removeItem('username');
            localStorage.removeItem('userId');

            // Use window.location to redirect outside of React Router context if needed
            // Check if already on login page to prevent loop
            if (!window.location.pathname.includes('/login')) {
                 window.location.href = '/login?sessionExpired=true'; // Redirect to login page
            }
        }
        // Return the error so that the calling code can handle it (e.g., display message)
        return Promise.reject(error);
    }
);
// --- End Interceptors ---


// --- NAMED EXPORTS for API functions ---

// Authentication
export const signupUser = (userData) => api.post('/auth/signup', userData);
export const signinUser = (userData) => api.post('/auth/signin', userData);

// Chat Interaction
// messageData includes { message, history, sessionId, systemPrompt, isRagEnabled, relevantDocs }
export const sendMessage = (messageData) => api.post('/chat/message', messageData);
export const saveChatHistory = (historyData) => api.post('/chat/history', historyData);

// RAG Query
// queryData includes { message }
export const queryRagService = (queryData) => api.post('/chat/rag', queryData);

// Chat History Retrieval
export const getChatSessions = () => api.get('/chat/sessions');
export const getSessionDetails = (sessionId) => api.get(`/chat/session/${sessionId}`);

// File Upload
// Pass FormData directly
export const uploadFile = (formData) => api.post('/upload', formData);

// File Management
export const getUserFiles = () => api.get('/files');
export const renameUserFile = (serverFilename, newOriginalName) => api.patch(`/files/${serverFilename}`, { newOriginalName });
export const deleteUserFile = (serverFilename) => api.delete(`/files/${serverFilename}`);


// --- DEFAULT EXPORT ---
// Export the configured Axios instance if needed for direct use elsewhere
export default api;

```

`src/setupTests.js`

```javascript
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

```

`test.py`

```python
import google.generativeai as genai

# Replace with your actual API key
API_KEY = "AIzaSyDs2GE0ttB2Q93w5SsW03SKXb1edNMbdcU"

# Configure the API key
genai.configure(api_key=API_KEY)

try:
    model = genai.GenerativeModel("gemini-1.5-flash")
    response = model.generate_content("Hello Gemini, how are you?")
    print("✅ Response from Gemini:")
    print(response.text)
except Exception as e:
    print("❌ Failed to connect to Gemini API:")
    print(e)

```

